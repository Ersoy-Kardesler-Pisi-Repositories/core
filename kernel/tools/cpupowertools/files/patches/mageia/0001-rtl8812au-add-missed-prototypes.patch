From 292797fe6f0fda6ab984e68d07eb97d85daa4837 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Giuseppe=20Ghib=C3=B2?= <ghibo@mageia.org>
Date: Wed, 20 Nov 2024 22:23:47 +0100
Subject: [PATCH] rtl8812au: add missed prototypes

---
 .../staging/rtl8812au/core/efuse/rtw_efuse.c  |  12 ++
 drivers/staging/rtl8812au/core/rtw_ap.c       |   4 +
 drivers/staging/rtl8812au/core/rtw_br_ext.c   |   4 +
 drivers/staging/rtl8812au/core/rtw_chplan.c   |   3 +-
 drivers/staging/rtl8812au/core/rtw_cmd.c      |  12 ++
 .../staging/rtl8812au/core/rtw_ieee80211.c    |   4 +
 drivers/staging/rtl8812au/core/rtw_mi.c       |   2 +
 drivers/staging/rtl8812au/core/rtw_mlme.c     |   5 +
 drivers/staging/rtl8812au/core/rtw_mlme_ext.c |  30 ++++-
 drivers/staging/rtl8812au/core/rtw_mp.c       |   4 +
 drivers/staging/rtl8812au/core/rtw_odm.c      |   3 +
 drivers/staging/rtl8812au/core/rtw_p2p.c      |  12 ++
 drivers/staging/rtl8812au/core/rtw_pwrctrl.c  |   2 +
 drivers/staging/rtl8812au/core/rtw_recv.c     |  27 ++++
 drivers/staging/rtl8812au/core/rtw_rf.c       |   2 +
 drivers/staging/rtl8812au/core/rtw_sreset.c   |   3 +
 drivers/staging/rtl8812au/core/rtw_sta_mgt.c  |   4 +
 drivers/staging/rtl8812au/core/rtw_vht.c      |   3 +
 .../staging/rtl8812au/core/rtw_wlan_util.c    |   7 ++
 drivers/staging/rtl8812au/core/rtw_xmit.c     |   5 +
 drivers/staging/rtl8812au/hal/hal_com.c       |  14 +++
 .../staging/rtl8812au/hal/hal_com_phycfg.c    |  83 +++++++++++++
 drivers/staging/rtl8812au/hal/hal_dm.c        |   7 +-
 drivers/staging/rtl8812au/hal/hal_intf.c      |   2 +
 drivers/staging/rtl8812au/hal/hal_mp.c        |  15 +++
 .../staging/rtl8812au/hal/led/hal_usb_led.c   | 109 +++++++++++++++++
 .../rtl8812au/hal/phydm/halrf/halphyrf_ce.c   |   3 +
 .../staging/rtl8812au/hal/phydm/halrf/halrf.c |   4 +
 .../rtl8812au/hal/phydm/halrf/halrf_debug.c   |   3 +
 .../rtl8812au/hal/phydm/halrf/halrf_kfree.c   |  26 ++++
 .../hal/phydm/halrf/halrf_powertracking_ce.c  |   2 +
 .../hal/phydm/halrf/rtl8812a/halrf_8812a_ce.c |  23 ++++
 .../hal/phydm/halrf/rtl8814a/halrf_8814a_ce.c |   9 ++
 .../phydm/halrf/rtl8814a/halrf_iqk_8814a.c    |  67 +++++++++-
 .../phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.c |  69 +++++++++++
 drivers/staging/rtl8812au/hal/phydm/phydm.c   |  15 +++
 .../rtl8812au/hal/phydm/phydm_adaptivity.c    |  11 ++
 .../rtl8812au/hal/phydm/phydm_adc_sampling.c  |   5 +
 .../staging/rtl8812au/hal/phydm/phydm_api.c   |  16 +++
 .../rtl8812au/hal/phydm/phydm_beamforming.c   | 107 ++++++++++++++++
 .../rtl8812au/hal/phydm/phydm_cck_pd.c        |   5 +
 .../staging/rtl8812au/hal/phydm/phydm_ccx.c   |  24 ++++
 .../rtl8812au/hal/phydm/phydm_cfotracking.c   |   3 +
 .../staging/rtl8812au/hal/phydm/phydm_debug.c |  41 +++++++
 .../staging/rtl8812au/hal/phydm/phydm_dig.c   |  23 ++++
 .../rtl8812au/hal/phydm/phydm_interface.c     |   1 +
 .../rtl8812au/hal/phydm/phydm_noisemonitor.c  |   5 +
 .../rtl8812au/hal/phydm/phydm_phystatus.c     |  29 +++++
 .../rtl8812au/hal/phydm/phydm_rainfo.c        |  16 +++
 .../rtl8812au/hal/phydm/phydm_rssi_monitor.c  |   2 +
 .../hal/phydm/rtl8821a/phydm_rtl8821a.c       |   8 ++
 .../rtl8812au/hal/phydm/txbf/halcomtxbf.c     |  16 +++
 .../rtl8812au/hal/phydm/txbf/haltxbf8814a.c   |   4 +
 .../rtl8812au/hal/phydm/txbf/haltxbfjaguar.c  |   8 ++
 .../rtl8812au/hal/rtl8812a/rtl8812a_cmd.c     |  13 ++
 .../hal/rtl8812a/rtl8812a_hal_init.c          |  89 ++++++++++++++
 .../rtl8812au/hal/rtl8812a/rtl8812a_phycfg.c  |  74 +++++++++++
 .../rtl8812au/hal/rtl8812a/usb/usb_halinit.c  |  65 +++++++++-
 .../hal/rtl8812a/usb/usb_ops_linux.c          |   1 +
 .../rtl8812au/hal/rtl8814a/rtl8814a_cmd.c     |  15 +++
 .../hal/rtl8814a/rtl8814a_hal_init.c          | 115 ++++++++++++++++++
 .../rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c  |  67 +++++++++-
 .../rtl8812au/hal/rtl8814a/usb/usb_halinit.c  |  58 ++++++++-
 .../hal/rtl8814a/usb/usb_ops_linux.c          |   1 +
 .../rtl8812au/os_dep/linux/ioctl_cfg80211.c   |  12 ++
 .../rtl8812au/os_dep/linux/ioctl_linux.c      |   2 +
 .../staging/rtl8812au/os_dep/linux/os_intfs.c |  18 ++-
 .../rtl8812au/os_dep/linux/rtw_android.c      |  11 ++
 .../staging/rtl8812au/os_dep/linux/rtw_proc.c |  13 ++
 .../staging/rtl8812au/os_dep/linux/usb_intf.c |   1 +
 .../rtl8812au/os_dep/linux/usb_ops_linux.c    |   1 +
 .../rtl8812au/os_dep/linux/xmit_linux.c       |   1 +
 .../staging/rtl8812au/os_dep/osdep_service.c  |   1 +
 .../staging/rtl8812au/platform/platform_ops.c |   2 +
 74 files changed, 1467 insertions(+), 16 deletions(-)

diff --git a/drivers/staging/rtl8812au/core/efuse/rtw_efuse.c b/drivers/staging/rtl8812au/core/efuse/rtw_efuse.c
index cca02619e..6587eb7fe 100644
--- a/drivers/staging/rtl8812au/core/efuse/rtw_efuse.c
+++ b/drivers/staging/rtl8812au/core/efuse/rtw_efuse.c
@@ -793,6 +793,9 @@ void rtw_efuse_analyze(PADAPTER	padapter, u8 Type, u8 Fake)
 		rtw_mfree((u8 *)eFuseWord, EFUSE_MAX_SECTION_NUM * (EFUSE_MAX_WORD_UNIT * 2));
 }
 
+VOID efuse_PreUpdateAction(
+	PADAPTER	pAdapter,
+	pu4Byte	BackupRegs);
 VOID efuse_PreUpdateAction(
 	PADAPTER	pAdapter,
 	pu4Byte	BackupRegs)
@@ -822,6 +825,9 @@ VOID efuse_PreUpdateAction(
 }
 
 
+VOID efuse_PostUpdateAction(
+	PADAPTER	pAdapter,
+	pu4Byte	BackupRegs);
 VOID efuse_PostUpdateAction(
 	PADAPTER	pAdapter,
 	pu4Byte	BackupRegs)
@@ -2214,6 +2220,12 @@ Efuse_PgPacketWrite(IN	PADAPTER	pAdapter,
 }
 
 
+int
+Efuse_PgPacketWrite_BT(IN	PADAPTER	pAdapter,
+		       IN	u8			offset,
+		       IN	u8			word_en,
+		       IN	u8			*data,
+		       IN	BOOLEAN		bPseudoTest);
 int
 Efuse_PgPacketWrite_BT(IN	PADAPTER	pAdapter,
 		       IN	u8			offset,
diff --git a/drivers/staging/rtl8812au/core/rtw_ap.c b/drivers/staging/rtl8812au/core/rtw_ap.c
index 1912448ba..7c3cc03e8 100644
--- a/drivers/staging/rtl8812au/core/rtw_ap.c
+++ b/drivers/staging/rtl8812au/core/rtw_ap.c
@@ -940,6 +940,7 @@ void rtw_update_bmc_sta_tx_rate(_adapter *adapter)
 }
 #endif
 
+void rtw_init_bmc_sta_tx_rate(_adapter *padapter, struct sta_info *psta);
 void rtw_init_bmc_sta_tx_rate(_adapter *padapter, struct sta_info *psta)
 {
 #ifdef CONFIG_BMC_TX_LOW_RATE
@@ -1027,6 +1028,7 @@ void update_bmc_sta(_adapter *padapter)
 }
 
 #if defined(CONFIG_80211N_HT) && defined(CONFIG_BEAMFORMING)
+void update_sta_info_apmode_ht_bf_cap(_adapter *padapter, struct sta_info *psta);
 void update_sta_info_apmode_ht_bf_cap(_adapter *padapter, struct sta_info *psta)
 {
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -2856,6 +2858,7 @@ int rtw_ap_set_wep_key(_adapter *padapter, u8 *key, u8 keylen, int keyid, u8 set
 	return rtw_ap_set_key(padapter, key, alg, keyid, set_tx);
 }
 
+u8 rtw_ap_bmc_frames_hdl(_adapter *padapter);
 u8 rtw_ap_bmc_frames_hdl(_adapter *padapter)
 {
 #define HIQ_XMIT_COUNTS (6)
@@ -4182,6 +4185,7 @@ void start_ap_mode(_adapter *padapter)
 
 }
 
+void rtw_ap_bcmc_sta_flush(_adapter *padapter);
 void rtw_ap_bcmc_sta_flush(_adapter *padapter)
 {
 #ifdef CONFIG_CONCURRENT_MODE
diff --git a/drivers/staging/rtl8812au/core/rtw_br_ext.c b/drivers/staging/rtl8812au/core/rtw_br_ext.c
index c80474e8b..955a50912 100644
--- a/drivers/staging/rtl8812au/core/rtw_br_ext.c
+++ b/drivers/staging/rtl8812au/core/rtw_br_ext.c
@@ -668,6 +668,7 @@ void nat25_db_cleanup(_adapter *priv)
 }
 
 
+void nat25_db_expire(_adapter *priv);
 void nat25_db_expire(_adapter *priv)
 {
 	int i;
@@ -784,6 +785,7 @@ static int checkIPMcAndReplace(_adapter *priv, struct sk_buff *skb, unsigned int
 }
 #endif
 
+int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method);
 int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 {
 	unsigned short protocol;
@@ -1193,6 +1195,7 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 }
 
 
+int nat25_handle_frame(_adapter *priv, struct sk_buff *skb);
 int nat25_handle_frame(_adapter *priv, struct sk_buff *skb)
 {
 #ifdef BR_EXT_DEBUG
@@ -1324,6 +1327,7 @@ struct dhcpMessage {
 	u_int8_t options[308]; /* 312 - cookie */
 };
 
+void dhcp_flag_bcast(_adapter *priv, struct sk_buff *skb);
 void dhcp_flag_bcast(_adapter *priv, struct sk_buff *skb)
 {
 	if (skb == NULL)
diff --git a/drivers/staging/rtl8812au/core/rtw_chplan.c b/drivers/staging/rtl8812au/core/rtw_chplan.c
index 34263a5fd..afefe957a 100644
--- a/drivers/staging/rtl8812au/core/rtw_chplan.c
+++ b/drivers/staging/rtl8812au/core/rtw_chplan.c
@@ -404,7 +404,8 @@ bool rtw_chplan_is_empty(u8 id)
 	return _FALSE;
 }
 
-bool rtw_regsty_is_excl_chs(struct registry_priv *regsty, u8 ch)
+bool rtw_regsty_is_excl_chs(struct registry_priv *regsty, u8 ch);
+bool rtw_regsty_is_excl_chs(struct registry_priv *regsty, u8 ch)
 {
 	int i;
 
diff --git a/drivers/staging/rtl8812au/core/rtw_cmd.c b/drivers/staging/rtl8812au/core/rtw_cmd.c
index ca4e35b9b..62bd059c6 100644
--- a/drivers/staging/rtl8812au/core/rtw_cmd.c
+++ b/drivers/staging/rtl8812au/core/rtw_cmd.c
@@ -2018,6 +2018,7 @@ u8 rtw_reset_securitypriv_cmd(_adapter *padapter)
 
 }
 
+void free_assoc_resources_hdl(_adapter *padapter, u8 lock_scanned_queue);
 void free_assoc_resources_hdl(_adapter *padapter, u8 lock_scanned_queue)
 {
 	rtw_free_assoc_resources(padapter, lock_scanned_queue);
@@ -2177,6 +2178,7 @@ u8 rtw_set_chbw_cmd(_adapter *padapter, u8 ch, u8 bw, u8 ch_offset, u8 flags)
 	return res;
 }
 
+u8 _rtw_set_chplan_cmd(_adapter *adapter, int flags, u8 chplan, const struct country_chplan *country_ent, u8 swconfig);
 u8 _rtw_set_chplan_cmd(_adapter *adapter, int flags, u8 chplan, const struct country_chplan *country_ent, u8 swconfig)
 {
 	struct cmd_obj *cmdobj;
@@ -2444,6 +2446,7 @@ u8 rtw_periodic_tsf_update_end_cmd(_adapter *adapter)
 exit:
 	return res;
 }
+u8 rtw_ssmps_wk_hdl(_adapter *adapter, struct ssmps_cmd_parm *ssmp_param);
 u8 rtw_ssmps_wk_hdl(_adapter *adapter, struct ssmps_cmd_parm *ssmp_param)
 {
 	u8 res = _SUCCESS;
@@ -3232,6 +3235,7 @@ void rtw_iface_dynamic_chk_wk_hdl(_adapter *padapter)
 #endif
 
 }
+void rtw_dynamic_chk_wk_hdl(_adapter *padapter);
 void rtw_dynamic_chk_wk_hdl(_adapter *padapter)
 {
 	rtw_mi_dynamic_chk_wk_hdl(padapter);
@@ -3609,6 +3613,7 @@ u8 rtw_antenna_select_cmd(_adapter *padapter, u8 antenna, u8 enqueue)
 }
 #endif
 
+void rtw_dm_ra_mask_hdl(_adapter *padapter, struct sta_info *psta);
 void rtw_dm_ra_mask_hdl(_adapter *padapter, struct sta_info *psta)
 {
 	if (psta)
@@ -3651,12 +3656,14 @@ u8 rtw_dm_ra_mask_wk_cmd(_adapter *padapter, u8 *psta)
 
 }
 
+void power_saving_wk_hdl(_adapter *padapter);
 void power_saving_wk_hdl(_adapter *padapter)
 {
 	rtw_ps_processor(padapter);
 }
 
 /* add for CONFIG_IEEE80211W, none 11w can use it */
+void reset_securitypriv_hdl(_adapter *padapter);
 void reset_securitypriv_hdl(_adapter *padapter)
 {
 	rtw_reset_securitypriv(padapter);
@@ -4903,6 +4910,7 @@ inline u8 rtw_customer_str_write_cmd(_adapter *adapter, const u8 *cstr)
 }
 #endif /* CONFIG_RTW_CUSTOMER_STR */
 
+u8 rtw_c2h_wk_cmd(PADAPTER padapter, u8 *pbuf, u16 length, u8 type);
 u8 rtw_c2h_wk_cmd(PADAPTER padapter, u8 *pbuf, u16 length, u8 type)
 {
 	struct cmd_obj *ph2c;
@@ -5021,6 +5029,7 @@ s32 c2h_evt_hdl(_adapter *adapter, u8 *c2h_evt, c2h_id_filter filter)
 }
 #endif /* CONFIG_FW_C2H_REG */
 
+u8 session_tracker_cmd(_adapter *adapter, u8 cmd, struct sta_info *sta, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
 u8 session_tracker_cmd(_adapter *adapter, u8 cmd, struct sta_info *sta, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port)
 {
 	struct cmd_priv	*cmdpriv = &adapter->cmdpriv;
@@ -5087,6 +5096,7 @@ inline u8 session_tracker_del_cmd(_adapter *adapter, struct sta_info *sta, u8 *l
 	return session_tracker_cmd(adapter, ST_CMD_DEL, sta, local_naddr, local_port, remote_naddr, remote_port);
 }
 
+void session_tracker_chk_for_sta(_adapter *adapter, struct sta_info *sta);
 void session_tracker_chk_for_sta(_adapter *adapter, struct sta_info *sta)
 {
 	struct st_ctl_t *st_ctl = &sta->st_ctl;
@@ -5169,6 +5179,7 @@ void session_tracker_chk_for_sta(_adapter *adapter, struct sta_info *sta)
 	return;
 }
 
+void session_tracker_chk_for_adapter(_adapter *adapter);
 void session_tracker_chk_for_adapter(_adapter *adapter)
 {
 	struct sta_priv *stapriv = &adapter->stapriv;
@@ -5201,6 +5212,7 @@ void session_tracker_chk_for_adapter(_adapter *adapter)
 #endif
 }
 
+void session_tracker_cmd_hdl(_adapter *adapter, struct st_cmd_parm *parm);
 void session_tracker_cmd_hdl(_adapter *adapter, struct st_cmd_parm *parm)
 {
 	u8 cmd = parm->cmd;
diff --git a/drivers/staging/rtl8812au/core/rtw_ieee80211.c b/drivers/staging/rtl8812au/core/rtw_ieee80211.c
index 01bf7ffb4..ddfe0b921 100644
--- a/drivers/staging/rtl8812au/core/rtw_ieee80211.c
+++ b/drivers/staging/rtl8812au/core/rtw_ieee80211.c
@@ -672,6 +672,7 @@ int rtw_get_wpa2_cipher_suite(u8 *s)
 	return 0;
 }
 
+u32 rtw_get_akm_suite_bitmap(u8 *s);
 u32 rtw_get_akm_suite_bitmap(u8 *s)
 {
 	if (_rtw_memcmp(s, WLAN_AKM_8021X, RSN_SELECTOR_LEN) == _TRUE)
@@ -1666,6 +1667,7 @@ void dump_ht_cap_ie_content(void *sel, const u8 *buf, u32 buf_len)
 		      , HT_SUP_MCS_SET_ARG(HT_CAP_ELE_SUP_MCS_SET(buf)));
 }
 
+void dump_ht_cap_ie(void *sel, const u8 *ie, u32 ie_len);
 void dump_ht_cap_ie(void *sel, const u8 *ie, u32 ie_len)
 {
 	const u8 *ht_cap_ie;
@@ -1685,6 +1687,7 @@ const char *const _ht_sc_offset_str[] = {
 	"SCB",
 };
 
+void dump_ht_op_ie_content(void *sel, const u8 *buf, u32 buf_len);
 void dump_ht_op_ie_content(void *sel, const u8 *buf, u32 buf_len)
 {
 	if (buf_len != HT_OP_IE_LEN) {
@@ -1699,6 +1702,7 @@ void dump_ht_op_ie_content(void *sel, const u8 *buf, u32 buf_len)
 	);
 }
 
+void dump_ht_op_ie(void *sel, const u8 *ie, u32 ie_len);
 void dump_ht_op_ie(void *sel, const u8 *ie, u32 ie_len)
 {
 	const u8 *ht_op_ie;
diff --git a/drivers/staging/rtl8812au/core/rtw_mi.c b/drivers/staging/rtl8812au/core/rtw_mi.c
index 2a9added7..409c9d2ca 100644
--- a/drivers/staging/rtl8812au/core/rtw_mi.c
+++ b/drivers/staging/rtl8812au/core/rtw_mi.c
@@ -883,6 +883,7 @@ void rtw_mi_buddy_xmit_tasklet_schedule(_adapter *padapter)
 }
 #endif
 
+u8 _rtw_mi_busy_traffic_check(_adapter *padapter, void *data);
 u8 _rtw_mi_busy_traffic_check(_adapter *padapter, void *data)
 {
 	u32 passtime;
@@ -1342,6 +1343,7 @@ _adapter *rtw_get_iface_by_hwport(_adapter *padapter, u8 hw_port)
 /*#define CONFIG_SKB_ALLOCATED*/
 #define DBG_SKB_PROCESS
 #ifdef DBG_SKB_PROCESS
+void rtw_dbg_skb_process(_adapter *padapter, union recv_frame *precvframe, union recv_frame *pcloneframe);
 void rtw_dbg_skb_process(_adapter *padapter, union recv_frame *precvframe, union recv_frame *pcloneframe)
 {
 	_pkt *pkt_copy, *pkt_org;
diff --git a/drivers/staging/rtl8812au/core/rtw_mlme.c b/drivers/staging/rtl8812au/core/rtw_mlme.c
index 573358826..daeb92407 100644
--- a/drivers/staging/rtl8812au/core/rtw_mlme.c
+++ b/drivers/staging/rtl8812au/core/rtw_mlme.c
@@ -20,6 +20,7 @@ extern void indicate_wx_scan_complete_event(_adapter *padapter);
 extern u8 rtw_do_join(_adapter *padapter);
 
 
+void rtw_init_mlme_timer(_adapter *padapter);
 void rtw_init_mlme_timer(_adapter *padapter)
 {
 	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -37,6 +38,7 @@ void rtw_init_mlme_timer(_adapter *padapter)
 #endif
 }
 
+sint	_rtw_init_mlme_priv(_adapter *padapter);
 sint	_rtw_init_mlme_priv(_adapter *padapter)
 {
 	sint	i;
@@ -295,6 +297,7 @@ int rtw_mlme_update_wfd_ie_data(struct mlme_priv *mlme, u8 type, u8 *ie, u32 ie_
 }
 #endif /* defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211) */
 
+void _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv);
 void _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)
 {
 	_adapter *adapter = mlme_to_adapter(pmlmepriv);
@@ -314,6 +317,7 @@ void _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)
 	return;
 }
 
+sint	_rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork);
 sint	_rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork)
 {
 	_irqL irqL;
@@ -1633,6 +1637,7 @@ static void free_scanqueue(struct	mlme_priv *pmlmepriv)
 
 }
 
+void rtw_reset_rx_info(_adapter *adapter);
 void rtw_reset_rx_info(_adapter *adapter)
 {
 	struct recv_priv  *precvpriv = &adapter->recvpriv;
diff --git a/drivers/staging/rtl8812au/core/rtw_mlme_ext.c b/drivers/staging/rtl8812au/core/rtw_mlme_ext.c
index 527e06dd5..0d79cde59 100644
--- a/drivers/staging/rtl8812au/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8812au/core/rtw_mlme_ext.c
@@ -1106,6 +1106,7 @@ static void init_mlme_ext_priv_value(_adapter *padapter)
 #endif /* ROKU_PRIVATE */
 }
 
+void init_mlme_ext_timer(_adapter *padapter);
 void init_mlme_ext_timer(_adapter *padapter)
 {
 	struct	mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
@@ -1380,6 +1381,7 @@ void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
 }
 
 #ifdef CONFIG_P2P
+u32 p2p_listen_state_process(_adapter *padapter, unsigned char *da);
 u32 p2p_listen_state_process(_adapter *padapter, unsigned char *da)
 {
 	bool response = _TRUE;
@@ -3081,7 +3083,8 @@ unsigned int OnAtim(_adapter *padapter, union recv_frame *precv_frame)
 	return _SUCCESS;
 }
 
-unsigned int on_action_spct_ch_switch(_adapter *padapter, struct sta_info *psta, u8 *ies, uint ies_len)
+unsigned int on_action_spct_ch_switch(_adapter *padapter, struct sta_info *psta, u8 *ies, uint ies_len);
+unsigned int on_action_spct_ch_switch(_adapter *padapter, struct sta_info *psta, u8 *ies, uint ies_len)
 {
 	unsigned int ret = _FAIL;
 	struct mlme_ext_priv *mlmeext = &padapter->mlmeextpriv;
@@ -4134,6 +4137,7 @@ void issue_p2p_GO_request(_adapter *padapter, u8 *raddr)
 }
 
 
+void issue_p2p_GO_response(_adapter *padapter, u8 *raddr, u8 *frame_body, uint len, u8 result);
 void issue_p2p_GO_response(_adapter *padapter, u8 *raddr, u8 *frame_body, uint len, u8 result)
 {
 	struct p2p_channels *ch_list = &(adapter_to_rfctl(padapter)->channel_list);
@@ -4556,6 +4560,7 @@ void issue_p2p_GO_response(_adapter *padapter, u8 *raddr, u8 *frame_body, uint l
 
 }
 
+void issue_p2p_GO_confirm(_adapter *padapter, u8 *raddr, u8 result);
 void issue_p2p_GO_confirm(_adapter *padapter, u8 *raddr, u8 result)
 {
 
@@ -5434,6 +5439,7 @@ void issue_p2p_provision_request(_adapter *padapter, u8 *pssid, u8 ussidlen, u8
 }
 
 
+u8 is_matched_in_profilelist(u8 *peermacaddr, struct profile_info *profileinfo);
 u8 is_matched_in_profilelist(u8 *peermacaddr, struct profile_info *profileinfo)
 {
 	u8 i, match_result = 0;
@@ -5786,6 +5792,7 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 
 }
 
+int _issue_probereq_p2p(_adapter *padapter, u8 *da, int wait_ack);
 int _issue_probereq_p2p(_adapter *padapter, u8 *da, int wait_ack)
 {
 	int ret = _FAIL;
@@ -6163,6 +6170,7 @@ int issue_probereq_p2p_ex(_adapter *adapter, u8 *da, int try_cnt, int wait_ms)
 
 #endif /* CONFIG_P2P */
 
+s32 rtw_action_public_decache(union recv_frame *rframe, u8 token_offset);
 s32 rtw_action_public_decache(union recv_frame *rframe, u8 token_offset)
 {
 	_adapter *adapter = rframe->u.hdr.adapter;
@@ -6188,7 +6196,8 @@ s32 rtw_action_public_decache(union recv_frame *rframe, u8 token_offset)
 	return _SUCCESS;
 }
 
-unsigned int on_action_public_p2p(union recv_frame *precv_frame)
+unsigned int on_action_public_p2p(union recv_frame *precv_frame);
+unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 {
 	_adapter *padapter = precv_frame->u.hdr.adapter;
 	u8 *pframe = precv_frame->u.hdr.rx_data;
@@ -6564,6 +6573,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 	return _SUCCESS;
 }
 
+unsigned int on_action_public_vendor(union recv_frame *precv_frame);
 unsigned int on_action_public_vendor(union recv_frame *precv_frame)
 {
 	unsigned int ret = _FAIL;
@@ -6594,6 +6604,7 @@ unsigned int on_action_public_vendor(union recv_frame *precv_frame)
 	return ret;
 }
 
+unsigned int on_action_public_default(union recv_frame *precv_frame, u8 action);
 unsigned int on_action_public_default(union recv_frame *precv_frame, u8 action)
 {
 	unsigned int ret = _FAIL;
@@ -7462,6 +7473,7 @@ unsigned int DoReserved(_adapter *padapter, union recv_frame *precv_frame)
 	return _SUCCESS;
 }
 
+struct xmit_frame *_alloc_mgtxmitframe(struct xmit_priv *pxmitpriv, bool once);
 struct xmit_frame *_alloc_mgtxmitframe(struct xmit_priv *pxmitpriv, bool once)
 {
 	struct xmit_frame *pmgntframe;
@@ -7762,6 +7774,7 @@ s32 dump_mgntframe_and_wait_ack(_adapter *padapter, struct xmit_frame *pmgntfram
 }
 
 
+int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode);
 int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode)
 {
 	u8 *ssid_ie;
@@ -8399,6 +8412,7 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 
 }
 
+int _issue_probereq(_adapter *padapter, const NDIS_802_11_SSID *pssid, const u8 *da, u8 ch, bool append_wps, int wait_ack);
 int _issue_probereq(_adapter *padapter, const NDIS_802_11_SSID *pssid, const u8 *da, u8 ch, bool append_wps, int wait_ack)
 {
 	int ret = _FAIL;
@@ -10560,6 +10574,7 @@ void issue_action_BSSCoexistPacket(_adapter *padapter)
 }
 
 /* Spatial Multiplexing Powersave (SMPS) action frame */
+int _issue_action_SM_PS(_adapter *padapter ,  unsigned char *raddr , u8 NewMimoPsMode ,  u8 wait_ack);
 int _issue_action_SM_PS(_adapter *padapter ,  unsigned char *raddr , u8 NewMimoPsMode ,  u8 wait_ack)
 {
 
@@ -12591,6 +12606,7 @@ When station does not receive any packet in MAX_CONTINUAL_NORXPACKET_COUNT*2 sec
 recipient station will teardown the block ack by issuing DELBA frame.
 
 *********************************************************************/
+void rtw_delba_check(_adapter *padapter, struct sta_info *psta, u8 from_timer);
 void rtw_delba_check(_adapter *padapter, struct sta_info *psta, u8 from_timer)
 {
 	int	i = 0;
@@ -12629,6 +12645,7 @@ void rtw_delba_check(_adapter *padapter, struct sta_info *psta, u8 from_timer)
 	}
 }
 
+u8 chk_ap_is_alive(_adapter *padapter, struct sta_info *psta);
 u8 chk_ap_is_alive(_adapter *padapter, struct sta_info *psta)
 {
 	u8 ret = _FALSE;
@@ -12669,6 +12686,7 @@ u8 chk_ap_is_alive(_adapter *padapter, struct sta_info *psta)
 	return ret;
 }
 
+u8 chk_adhoc_peer_is_alive(struct sta_info *psta);
 u8 chk_adhoc_peer_is_alive(struct sta_info *psta)
 {
 	u8 ret = _TRUE;
@@ -13210,6 +13228,7 @@ void addba_timer_hdl(void *ctx)
 }
 
 #ifdef CONFIG_IEEE80211W
+void report_sta_timeout_event(_adapter *padapter, u8 *MacAddr, unsigned short reason);
 void report_sta_timeout_event(_adapter *padapter, u8 *MacAddr, unsigned short reason)
 {
 	struct cmd_obj *pcmd_obj;
@@ -13267,6 +13286,7 @@ void report_sta_timeout_event(_adapter *padapter, u8 *MacAddr, unsigned short re
 	return;
 }
 
+void clnt_sa_query_timeout(_adapter *padapter);
 void clnt_sa_query_timeout(_adapter *padapter)
 {
 	struct mlme_ext_priv *mlmeext = &(padapter->mlmeextpriv);
@@ -14253,6 +14273,7 @@ static bool scan_abort_hdl(_adapter *adapter)
 	return ret;
 }
 
+u8 rtw_scan_sparse(_adapter *adapter, struct rtw_ieee80211_channel *ch, u8 ch_num);
 u8 rtw_scan_sparse(_adapter *adapter, struct rtw_ieee80211_channel *ch, u8 ch_num)
 {
 	/* interval larger than this is treated as backgroud scan */
@@ -14357,6 +14378,7 @@ u8 rtw_scan_sparse(_adapter *adapter, struct rtw_ieee80211_channel *ch, u8 ch_nu
 }
 
 #ifdef CONFIG_SCAN_BACKOP
+u8 rtw_scan_backop_decision(_adapter *adapter);
 u8 rtw_scan_backop_decision(_adapter *adapter)
 {
 	struct mlme_ext_priv *mlmeext = &adapter->mlmeextpriv;
@@ -14772,6 +14794,7 @@ void site_survey(_adapter *padapter, u8 survey_channel, RT_SCAN_TYPE ScanType)
 	return;
 }
 
+void survey_done_set_ch_bw(_adapter *padapter);
 void survey_done_set_ch_bw(_adapter *padapter)
 {
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
@@ -14842,6 +14865,7 @@ void survey_done_set_ch_bw(_adapter *padapter)
  *
  * Returns: 0: no ps announcement is doing. 1: ps announcement is doing
  */
+u8 rtw_ps_annc(_adapter *adapter, bool ps);
 u8 rtw_ps_annc(_adapter *adapter, bool ps)
 {
 	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
@@ -14931,6 +14955,7 @@ void rtw_back_opch(_adapter *adapter)
 	_exit_critical_mutex(&rfctl->offch_mutex, NULL);
 }
 
+void sitesurvey_set_igi(_adapter *adapter);
 void sitesurvey_set_igi(_adapter *adapter)
 {
 	struct mlme_ext_priv *mlmeext = &adapter->mlmeextpriv;
@@ -14991,6 +15016,7 @@ void sitesurvey_set_igi(_adapter *adapter)
 		break;
 	}
 }
+void sitesurvey_set_msr(_adapter *adapter, bool enter);
 void sitesurvey_set_msr(_adapter *adapter, bool enter)
 {
 	u8 network_type;
diff --git a/drivers/staging/rtl8812au/core/rtw_mp.c b/drivers/staging/rtl8812au/core/rtw_mp.c
index bb7f78a4c..8d4966e32 100644
--- a/drivers/staging/rtl8812au/core/rtw_mp.c
+++ b/drivers/staging/rtl8812au/core/rtw_mp.c
@@ -362,6 +362,7 @@ static VOID PHY_SetRFPathSwitch_default(
 }
 #endif
 
+void mpt_InitHWConfig(PADAPTER Adapter);
 void mpt_InitHWConfig(PADAPTER Adapter)
 {
 	PHAL_DATA_TYPE hal;
@@ -1187,6 +1188,7 @@ int SetTxPower(PADAPTER pAdapter)
 	return _TRUE;
 }
 
+void SetTxAGCOffset(PADAPTER pAdapter, u32 ulTxAGCOffset);
 void SetTxAGCOffset(PADAPTER pAdapter, u32 ulTxAGCOffset)
 {
 	u32 TxAGCOffset_B, TxAGCOffset_C, TxAGCOffset_D, tmpAGC;
@@ -1483,6 +1485,7 @@ void fill_tx_desc_8188e(PADAPTER padapter)
 #endif
 
 #if defined(CONFIG_RTL8814A)
+void fill_tx_desc_8814a(PADAPTER padapter);
 void fill_tx_desc_8814a(PADAPTER padapter)
 {
 	struct mp_priv *pmp_priv = &padapter->mppriv;
@@ -1541,6 +1544,7 @@ void fill_tx_desc_8814a(PADAPTER padapter)
 #endif
 
 #if defined(CONFIG_RTL8812A) || defined(CONFIG_RTL8821A)
+void fill_tx_desc_8812a(PADAPTER padapter);
 void fill_tx_desc_8812a(PADAPTER padapter)
 {
 	struct mp_priv *pmp_priv = &padapter->mppriv;
diff --git a/drivers/staging/rtl8812au/core/rtw_odm.c b/drivers/staging/rtl8812au/core/rtw_odm.c
index 4e1151d51..336dd9236 100644
--- a/drivers/staging/rtl8812au/core/rtw_odm.c
+++ b/drivers/staging/rtl8812au/core/rtw_odm.c
@@ -64,6 +64,7 @@ void rtw_odm_init_ic_type(_adapter *adapter)
 	odm_cmn_info_init(odm, ODM_CMNINFO_IC_TYPE, ic_type);
 }
 
+void rtw_odm_adaptivity_ver_msg(void *sel, _adapter *adapter);
 void rtw_odm_adaptivity_ver_msg(void *sel, _adapter *adapter)
 {
 	RTW_PRINT_SEL(sel, "ADAPTIVITY_VERSION "ADAPTIVITY_VERSION"\n");
@@ -72,6 +73,7 @@ void rtw_odm_adaptivity_ver_msg(void *sel, _adapter *adapter)
 #define RTW_ADAPTIVITY_EN_DISABLE 0
 #define RTW_ADAPTIVITY_EN_ENABLE 1
 
+void rtw_odm_adaptivity_en_msg(void *sel, _adapter *adapter);
 void rtw_odm_adaptivity_en_msg(void *sel, _adapter *adapter)
 {
 	struct registry_priv *regsty = &adapter->registrypriv;
@@ -89,6 +91,7 @@ void rtw_odm_adaptivity_en_msg(void *sel, _adapter *adapter)
 #define RTW_ADAPTIVITY_MODE_NORMAL 0
 #define RTW_ADAPTIVITY_MODE_CARRIER_SENSE 1
 
+void rtw_odm_adaptivity_mode_msg(void *sel, _adapter *adapter);
 void rtw_odm_adaptivity_mode_msg(void *sel, _adapter *adapter)
 {
 	struct registry_priv *regsty = &adapter->registrypriv;
diff --git a/drivers/staging/rtl8812au/core/rtw_p2p.c b/drivers/staging/rtl8812au/core/rtw_p2p.c
index f66fa7155..167dd067f 100644
--- a/drivers/staging/rtl8812au/core/rtw_p2p.c
+++ b/drivers/staging/rtl8812au/core/rtw_p2p.c
@@ -18,6 +18,7 @@
 
 #ifdef CONFIG_P2P
 
+int rtw_p2p_is_channel_list_ok(u8 desired_ch, u8 *ch_list, u8 ch_cnt);
 int rtw_p2p_is_channel_list_ok(u8 desired_ch, u8 *ch_list, u8 ch_cnt)
 {
 	int found = 0, i = 0;
@@ -31,6 +32,7 @@ int rtw_p2p_is_channel_list_ok(u8 desired_ch, u8 *ch_list, u8 ch_cnt)
 	return found ;
 }
 
+int is_any_client_associated(_adapter *padapter);
 int is_any_client_associated(_adapter *padapter)
 {
 	return padapter->stapriv.asoc_list_cnt ? _TRUE : _FALSE;
@@ -2551,6 +2553,7 @@ u8 process_p2p_provdisc_resp(struct wifidirect_info *pwdinfo,  u8 *pframe)
 	return _TRUE;
 }
 
+u8 rtw_p2p_get_peer_ch_list(struct wifidirect_info *pwdinfo, u8 *ch_content, u8 ch_cnt, u8 *peer_ch_list);
 u8 rtw_p2p_get_peer_ch_list(struct wifidirect_info *pwdinfo, u8 *ch_content, u8 ch_cnt, u8 *peer_ch_list)
 {
 	u8 i = 0, j = 0;
@@ -2573,6 +2576,7 @@ u8 rtw_p2p_get_peer_ch_list(struct wifidirect_info *pwdinfo, u8 *ch_content, u8
 	return ch_no;
 }
 
+u8 rtw_p2p_ch_inclusion(_adapter *adapter, u8 *peer_ch_list, u8 peer_ch_num, u8 *ch_list_inclusioned);
 u8 rtw_p2p_ch_inclusion(_adapter *adapter, u8 *peer_ch_list, u8 peer_ch_num, u8 *ch_list_inclusioned)
 {
 	struct rf_ctl_t *rfctl = adapter_to_rfctl(adapter);
@@ -3068,6 +3072,7 @@ u8 process_p2p_presence_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint le
 	return _TRUE;
 }
 
+void find_phase_handler(_adapter	*padapter);
 void find_phase_handler(_adapter	*padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
@@ -3093,6 +3098,7 @@ void find_phase_handler(_adapter	*padapter)
 
 void p2p_concurrent_handler(_adapter *padapter);
 
+void restore_p2p_state_handler(_adapter	*padapter);
 void restore_p2p_state_handler(_adapter	*padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
@@ -3126,6 +3132,7 @@ void restore_p2p_state_handler(_adapter	*padapter)
 	}
 }
 
+void pre_tx_invitereq_handler(_adapter	*padapter);
 void pre_tx_invitereq_handler(_adapter	*padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
@@ -3138,6 +3145,7 @@ void pre_tx_invitereq_handler(_adapter	*padapter)
 
 }
 
+void pre_tx_provdisc_handler(_adapter	*padapter);
 void pre_tx_provdisc_handler(_adapter	*padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
@@ -3150,6 +3158,7 @@ void pre_tx_provdisc_handler(_adapter	*padapter)
 
 }
 
+void pre_tx_negoreq_handler(_adapter	*padapter);
 void pre_tx_negoreq_handler(_adapter	*padapter)
 {
 	struct wifidirect_info  *pwdinfo = &padapter->wdinfo;
@@ -3737,6 +3746,7 @@ static void rtw_cfg80211_adjust_p2pie_channel(_adapter *padapter, const u8 *fram
 #endif
 
 #ifdef CONFIG_WFD
+u32 rtw_xframe_build_wfd_ie(struct xmit_frame *xframe);
 u32 rtw_xframe_build_wfd_ie(struct xmit_frame *xframe)
 {
 	_adapter *adapter = xframe->padapter;
@@ -3815,6 +3825,7 @@ u32 rtw_xframe_build_wfd_ie(struct xmit_frame *xframe)
 }
 #endif /* CONFIG_WFD */
 
+bool rtw_xframe_del_wfd_ie(struct xmit_frame *xframe);
 bool rtw_xframe_del_wfd_ie(struct xmit_frame *xframe)
 {
 #define DBG_XFRAME_DEL_WFD_IE 0
@@ -3939,6 +3950,7 @@ u8 *dump_p2p_attr_ch_list(u8 *p2p_ie, uint p2p_ielen, u8 *buf, u32 buf_len)
 /*
  * return _TRUE if requester is GO, _FALSE if responder is GO
  */
+bool rtw_p2p_nego_intent_compare(u8 req, u8 resp);
 bool rtw_p2p_nego_intent_compare(u8 req, u8 resp)
 {
 	if (req >> 1 == resp >> 1)
diff --git a/drivers/staging/rtl8812au/core/rtw_pwrctrl.c b/drivers/staging/rtl8812au/core/rtw_pwrctrl.c
index 34e10dc0a..44d702868 100644
--- a/drivers/staging/rtl8812au/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8812au/core/rtw_pwrctrl.c
@@ -194,6 +194,7 @@ int ips_leave(_adapter *padapter)
 	int rtw_hw_resume(_adapter *padapter);
 #endif
 
+bool rtw_pwr_unassociated_idle(_adapter *adapter);
 bool rtw_pwr_unassociated_idle(_adapter *adapter)
 {
 	u8 i;
@@ -400,6 +401,7 @@ void rtw_ps_processor(_adapter *padapter)
 	return;
 }
 
+void pwr_state_check_handler(void *ctx);
 void pwr_state_check_handler(void *ctx)
 {
 	_adapter *padapter = (_adapter *)ctx;
diff --git a/drivers/staging/rtl8812au/core/rtw_recv.c b/drivers/staging/rtl8812au/core/rtw_recv.c
index 3c180740b..ed2bf605c 100644
--- a/drivers/staging/rtl8812au/core/rtw_recv.c
+++ b/drivers/staging/rtl8812au/core/rtw_recv.c
@@ -851,6 +851,7 @@ sint recv_bcast_pn_decache(union recv_frame *precv_frame)
 	return _SUCCESS;
 }
 
+sint recv_decache(union recv_frame *precv_frame);
 sint recv_decache(union recv_frame *precv_frame)
 {
 	struct sta_info *psta = precv_frame->u.hdr.psta;
@@ -906,6 +907,7 @@ sint recv_decache(union recv_frame *precv_frame)
 	return _SUCCESS;
 }
 
+void process_pwrbit_data(_adapter *padapter, union recv_frame *precv_frame, struct sta_info *psta);
 void process_pwrbit_data(_adapter *padapter, union recv_frame *precv_frame, struct sta_info *psta)
 {
 #ifdef CONFIG_AP_MODE
@@ -934,6 +936,7 @@ void process_pwrbit_data(_adapter *padapter, union recv_frame *precv_frame, stru
 #endif
 }
 
+void process_wmmps_data(_adapter *padapter, union recv_frame *precv_frame, struct sta_info *psta);
 void process_wmmps_data(_adapter *padapter, union recv_frame *precv_frame, struct sta_info *psta)
 {
 #ifdef CONFIG_AP_MODE
@@ -1167,6 +1170,11 @@ void count_rx_stats(_adapter *padapter, union recv_frame *prframe, struct sta_in
 
 }
 
+sint sta2sta_data_frame(
+	_adapter *adapter,
+	union recv_frame *precv_frame,
+	struct sta_info **psta
+);
 sint sta2sta_data_frame(
 	_adapter *adapter,
 	union recv_frame *precv_frame,
@@ -1346,6 +1354,10 @@ sint sta2sta_data_frame(
 
 }
 
+sint ap2sta_data_frame(
+	_adapter *adapter,
+	union recv_frame *precv_frame,
+	struct sta_info **psta);
 sint ap2sta_data_frame(
 	_adapter *adapter,
 	union recv_frame *precv_frame,
@@ -1486,6 +1498,10 @@ sint ap2sta_data_frame(
 
 }
 
+sint sta2ap_data_frame(
+	_adapter *adapter,
+	union recv_frame *precv_frame,
+	struct sta_info **psta);
 sint sta2ap_data_frame(
 	_adapter *adapter,
 	union recv_frame *precv_frame,
@@ -1960,6 +1976,7 @@ static sint validate_mgmt_protect(_adapter *adapter, union recv_frame *precv_fra
 
 union recv_frame *recvframe_chk_defrag(PADAPTER padapter, union recv_frame *precv_frame);
 
+sint validate_recv_mgnt_frame(PADAPTER padapter, union recv_frame *precv_frame);
 sint validate_recv_mgnt_frame(PADAPTER padapter, union recv_frame *precv_frame)
 {
 	struct sta_info *psta = precv_frame->u.hdr.psta
@@ -2051,6 +2068,7 @@ sint validate_recv_mgnt_frame(PADAPTER padapter, union recv_frame *precv_frame)
 
 }
 
+sint validate_recv_data_frame(_adapter *adapter, union recv_frame *precv_frame);
 sint validate_recv_data_frame(_adapter *adapter, union recv_frame *precv_frame)
 {
 	u8 bretry, a4_shift;
@@ -2408,6 +2426,7 @@ sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 
 /* remove the wlanhdr and add the eth_hdr */
 #if 1
+sint wlanhdr_to_ethhdr(union recv_frame *precvframe);
 sint wlanhdr_to_ethhdr(union recv_frame *precvframe)
 {
 	sint	rmv_len;
@@ -3013,6 +3032,7 @@ static void recv_fwd_pkt_hdl(_adapter *adapter, _pkt *pkt
 }
 #endif /* CONFIG_RTW_MESH */
 
+int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe);
 int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 {
 	struct rx_pkt_attrib *rattrib = &prframe->u.hdr.attrib;
@@ -3649,6 +3669,7 @@ static void recv_set_iseq_after_mpdu_process(union recv_frame *rframe, u16 seq_n
 }
 
 #ifdef CONFIG_MP_INCLUDED
+int validate_mp_recv_frame(_adapter *adapter, union recv_frame *precv_frame);
 int validate_mp_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 {
 	int ret = _SUCCESS;
@@ -3785,6 +3806,7 @@ static sint MPwlanhdr_to_ethhdr(union recv_frame *precvframe)
 }
 
 
+int mp_recv_frame(_adapter *padapter, union recv_frame *rframe);
 int mp_recv_frame(_adapter *padapter, union recv_frame *rframe)
 {
 	int ret = _SUCCESS;
@@ -4290,6 +4312,7 @@ static sint fill_radiotap_hdr(_adapter *padapter, union recv_frame *precvframe,
 
 }
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24))
+int recv_frame_monitor(_adapter *padapter, union recv_frame *rframe);
 int recv_frame_monitor(_adapter *padapter, union recv_frame *rframe)
 {
 	int ret = _SUCCESS;
@@ -4336,6 +4359,7 @@ int recv_frame_monitor(_adapter *padapter, union recv_frame *rframe)
 	return ret;
 }
 #endif
+int recv_func_prehandle(_adapter *padapter, union recv_frame *rframe);
 int recv_func_prehandle(_adapter *padapter, union recv_frame *rframe)
 {
 	int ret = _SUCCESS;
@@ -4373,6 +4397,7 @@ int recv_func_prehandle(_adapter *padapter, union recv_frame *rframe)
 }
 
 /*#define DBG_RX_BMC_FRAME*/
+int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe);
 int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
 {
 	int ret = _SUCCESS;
@@ -4481,6 +4506,7 @@ int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
 	return ret;
 }
 
+int recv_func(_adapter *padapter, union recv_frame *rframe);
 int recv_func(_adapter *padapter, union recv_frame *rframe)
 {
 	int ret;
@@ -4794,6 +4820,7 @@ static void rx_process_link_qual(_adapter *padapter, union recv_frame *prframe)
 #endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 }
 
+void rx_process_phy_info(_adapter *padapter, union recv_frame *rframe);
 void rx_process_phy_info(_adapter *padapter, union recv_frame *rframe)
 {
 	/* Check RSSI */
diff --git a/drivers/staging/rtl8812au/core/rtw_rf.c b/drivers/staging/rtl8812au/core/rtw_rf.c
index 6d827c364..eb884c3ce 100644
--- a/drivers/staging/rtl8812au/core/rtw_rf.c
+++ b/drivers/staging/rtl8812au/core/rtw_rf.c
@@ -588,6 +588,7 @@ const char *const _regd_str[] = {
 };
 
 #if CONFIG_TXPWR_LIMIT
+void _dump_regd_exc_list(void *sel, struct rf_ctl_t *rfctl);
 void _dump_regd_exc_list(void *sel, struct rf_ctl_t *rfctl)
 {
 	struct regd_exc_ent *ent;
@@ -1219,6 +1220,7 @@ int rtw_ch_to_bb_gain_sel(int ch)
 	return sel;
 }
 
+s8 rtw_rf_get_kfree_tx_gain_offset(_adapter *padapter, u8 path, u8 ch);
 s8 rtw_rf_get_kfree_tx_gain_offset(_adapter *padapter, u8 path, u8 ch)
 {
 	s8 kfree_offset = 0;
diff --git a/drivers/staging/rtl8812au/core/rtw_sreset.c b/drivers/staging/rtl8812au/core/rtw_sreset.c
index 03dba20f3..d3d4447b3 100644
--- a/drivers/staging/rtl8812au/core/rtw_sreset.c
+++ b/drivers/staging/rtl8812au/core/rtw_sreset.c
@@ -101,6 +101,7 @@ bool sreset_inprogress(_adapter *padapter)
 #endif
 }
 
+void sreset_restore_security_station(_adapter *padapter);
 void sreset_restore_security_station(_adapter *padapter)
 {
 	struct mlme_priv *mlmepriv = &padapter->mlmepriv;
@@ -137,6 +138,7 @@ void sreset_restore_security_station(_adapter *padapter)
 	}
 }
 
+void sreset_restore_network_station(_adapter *padapter);
 void sreset_restore_network_station(_adapter *padapter)
 {
 	struct mlme_priv *mlmepriv = &padapter->mlmepriv;
@@ -195,6 +197,7 @@ void sreset_restore_network_station(_adapter *padapter)
 }
 
 
+void sreset_restore_network_status(_adapter *padapter);
 void sreset_restore_network_status(_adapter *padapter)
 {
 	struct mlme_priv *mlmepriv = &padapter->mlmepriv;
diff --git a/drivers/staging/rtl8812au/core/rtw_sta_mgt.c b/drivers/staging/rtl8812au/core/rtw_sta_mgt.c
index ddcd1f70b..b42102142 100644
--- a/drivers/staging/rtl8812au/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8812au/core/rtw_sta_mgt.c
@@ -16,6 +16,7 @@
 
 #include <drv_types.h>
 
+bool test_st_match_rule(_adapter *adapter, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port);
 bool test_st_match_rule(_adapter *adapter, u8 *local_naddr, u8 *local_port, u8 *remote_naddr, u8 *remote_port)
 {
 	if (ntohs(*((u16 *)local_port)) == 5001 || ntohs(*((u16 *)remote_port)) == 5001)
@@ -365,6 +366,7 @@ static void	_rtw_free_sta_recv_priv_lock(struct sta_recv_priv *psta_recvpriv)
 
 }
 
+void rtw_mfree_stainfo(struct sta_info *psta);
 void rtw_mfree_stainfo(struct sta_info *psta)
 {
 
@@ -376,6 +378,7 @@ void rtw_mfree_stainfo(struct sta_info *psta)
 }
 
 /* this function is used to free the memory of lock || sema for all stainfos */
+void rtw_mfree_all_stainfo(struct sta_priv *pstapriv);
 void rtw_mfree_all_stainfo(struct sta_priv *pstapriv)
 {
 	_irqL	 irqL;
@@ -1044,6 +1047,7 @@ const char *const _acl_mode_str[RTW_ACL_MODE_MAX] = {
 	"DENY_UNLESS_LISTED",
 };
 
+u8 _rtw_access_ctrl(_adapter *adapter, u8 period, const u8 *mac_addr);
 u8 _rtw_access_ctrl(_adapter *adapter, u8 period, const u8 *mac_addr)
 {
 	u8 res = _TRUE;
diff --git a/drivers/staging/rtl8812au/core/rtw_vht.c b/drivers/staging/rtl8812au/core/rtw_vht.c
index 9a7608c8e..382813830 100644
--- a/drivers/staging/rtl8812au/core/rtw_vht.c
+++ b/drivers/staging/rtl8812au/core/rtw_vht.c
@@ -39,6 +39,7 @@ const char *const _vht_sup_ch_width_set_str[] = {
 	"BW-RSVD",
 };
 
+void dump_vht_cap_ie_content(void *sel, const u8 *buf, u32 buf_len);
 void dump_vht_cap_ie_content(void *sel, const u8 *buf, u32 buf_len)
 {
 	if (buf_len != VHT_CAP_IE_LEN) {
@@ -79,6 +80,7 @@ const char *const _vht_op_ch_width_str[] = {
 	"BW-RSVD",
 };
 
+void dump_vht_op_ie_content(void *sel, const u8 *buf, u32 buf_len);
 void dump_vht_op_ie_content(void *sel, const u8 *buf, u32 buf_len)
 {
 	if (buf_len != VHT_OP_IE_LEN) {
@@ -359,6 +361,7 @@ u64	rtw_vht_mcs_map_to_bitmap(u8 *mcs_map, u8 nss)
 }
 
 #ifdef CONFIG_BEAMFORMING
+void update_sta_vht_info_apmode_bf_cap(_adapter *padapter, struct sta_info *psta);
 void update_sta_vht_info_apmode_bf_cap(_adapter *padapter, struct sta_info *psta)
 {
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
diff --git a/drivers/staging/rtl8812au/core/rtw_wlan_util.c b/drivers/staging/rtl8812au/core/rtw_wlan_util.c
index 817245957..a427c7c51 100644
--- a/drivers/staging/rtl8812au/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8812au/core/rtw_wlan_util.c
@@ -1011,6 +1011,7 @@ inline bool rtw_sec_camid_is_drv_forbid(struct cam_ctl_t *cam_ctl, u8 id)
 	return 1;
 }
 
+bool _rtw_sec_camid_is_used(struct cam_ctl_t *cam_ctl, u8 id);
 bool _rtw_sec_camid_is_used(struct cam_ctl_t *cam_ctl, u8 id)
 {
 	bool ret = _FALSE;
@@ -1099,6 +1100,7 @@ inline bool rtw_camid_is_gk(_adapter *adapter, u8 cam_id)
 	return ret;
 }
 
+bool cam_cache_chk(_adapter *adapter, u8 id, u8 *addr, s16 kid, s8 gk);
 bool cam_cache_chk(_adapter *adapter, u8 id, u8 *addr, s16 kid, s8 gk)
 {
 	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
@@ -1117,6 +1119,7 @@ bool cam_cache_chk(_adapter *adapter, u8 id, u8 *addr, s16 kid, s8 gk)
 	return ret;
 }
 
+s16 _rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid, s8 gk);
 s16 _rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid, s8 gk)
 {
 	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
@@ -1157,6 +1160,7 @@ s16 rtw_camid_search(_adapter *adapter, u8 *addr, s16 kid, s8 gk)
 	return cam_id;
 }
 
+s16 rtw_get_camid(_adapter *adapter, u8 *addr, s16 kid, u8 gk);
 s16 rtw_get_camid(_adapter *adapter, u8 *addr, s16 kid, u8 gk)
 {
 	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
@@ -1276,6 +1280,7 @@ s16 rtw_camid_alloc(_adapter *adapter, struct sta_info *sta, u8 kid, u8 gk, bool
 	return cam_id;
 }
 
+void rtw_camid_set(_adapter *adapter, u8 cam_id);
 void rtw_camid_set(_adapter *adapter, u8 cam_id)
 {
 	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
@@ -1359,6 +1364,7 @@ inline void rtw_sec_cam_swap(_adapter *adapter, u8 cam_id_a, u8 cam_id_b)
 	}
 }
 
+s16 rtw_get_empty_cam_entry(_adapter *adapter, u8 start_camid);
 s16 rtw_get_empty_cam_entry(_adapter *adapter, u8 start_camid)
 {
 	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
@@ -2232,6 +2238,7 @@ void	update_ldpc_stbc_cap(struct sta_info *psta)
 #endif /* CONFIG_80211N_HT */
 }
 
+int check_ielen(u8 *start, uint len);
 int check_ielen(u8 *start, uint len)
 {
 	int left = len;
diff --git a/drivers/staging/rtl8812au/core/rtw_xmit.c b/drivers/staging/rtl8812au/core/rtw_xmit.c
index 8504dba09..0b97e5099 100644
--- a/drivers/staging/rtl8812au/core/rtw_xmit.c
+++ b/drivers/staging/rtl8812au/core/rtw_xmit.c
@@ -56,6 +56,7 @@ void rtw_init_xmit_block(_adapter *padapter)
 	dvobj->xmit_block = XMIT_BLOCK_NONE;
 
 }
+void rtw_free_xmit_block(_adapter *padapter);
 void rtw_free_xmit_block(_adapter *padapter)
 {
 	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
@@ -505,6 +506,7 @@ void rtw_get_adapter_tx_rate_bmp_by_bw(_adapter *adapter, u8 bw, u16 *r_bmp_cck_
 		*r_bmp_vht = bmp_vht;
 }
 
+void rtw_get_shared_macid_tx_rate_bmp_by_bw(struct dvobj_priv *dvobj, u8 bw, u16 *r_bmp_cck_ofdm, u32 *r_bmp_ht, u32 *r_bmp_vht);
 void rtw_get_shared_macid_tx_rate_bmp_by_bw(struct dvobj_priv *dvobj, u8 bw, u16 *r_bmp_cck_ofdm, u32 *r_bmp_ht, u32 *r_bmp_vht)
 {
 	struct macid_ctl_t *macid_ctl = dvobj_to_macidctl(dvobj);
@@ -3476,6 +3478,7 @@ s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
 	return _SUCCESS;
 }
 
+void rtw_init_xmitframe(struct xmit_frame *pxframe);
 void rtw_init_xmitframe(struct xmit_frame *pxframe)
 {
 	if (pxframe !=  NULL) { /* default value setting */
@@ -4146,6 +4149,7 @@ void rtw_init_hwxmits(struct hw_xmit *phwxmit, sint entry)
 }
 
 #ifdef CONFIG_BR_EXT
+int rtw_br_client_tx(_adapter *padapter, struct sk_buff **pskb);
 int rtw_br_client_tx(_adapter *padapter, struct sk_buff **pskb)
 {
 	struct sk_buff *skb = *pskb;
@@ -6040,6 +6044,7 @@ int rtw_sctx_wait(struct submit_ctx *sctx, const char *msg)
 	return ret;
 }
 
+bool rtw_sctx_chk_waring_status(int status);
 bool rtw_sctx_chk_waring_status(int status)
 {
 	switch (status) {
diff --git a/drivers/staging/rtl8812au/hal/hal_com.c b/drivers/staging/rtl8812au/hal/hal_com.c
index b3b1e16c8..a230ea6e5 100644
--- a/drivers/staging/rtl8812au/hal/hal_com.c
+++ b/drivers/staging/rtl8812au/hal/hal_com.c
@@ -2021,6 +2021,7 @@ void rtw_hal_update_sta_wset(_adapter *adapter, struct sta_info *psta)
 	psta->cmn.support_wireless_set = w_set;
 }
 
+void rtw_hal_update_sta_mimo_type(_adapter *adapter, struct sta_info *psta);
 void rtw_hal_update_sta_mimo_type(_adapter *adapter, struct sta_info *psta)
 {
 	s8 tx_nss, rx_nss;
@@ -2054,6 +2055,7 @@ void rtw_hal_update_sta_mimo_type(_adapter *adapter, struct sta_info *psta)
 			psta->cmn.mac_id, tx_nss, rx_nss);
 }
 
+void rtw_hal_update_sta_smps_cap(_adapter *adapter, struct sta_info *psta);
 void rtw_hal_update_sta_smps_cap(_adapter *adapter, struct sta_info *psta)
 {
 	/*Spatial Multiplexing Power Save*/
@@ -2092,6 +2094,7 @@ u8 rtw_get_mgntframe_raid(_adapter *adapter, unsigned char network_type)
 	return raid;
 }
 
+void rtw_hal_update_sta_rate_mask(PADAPTER padapter, struct sta_info *psta);
 void rtw_hal_update_sta_rate_mask(PADAPTER padapter, struct sta_info *psta)
 {
 	struct hal_spec_t *hal_spec = GET_HAL_SPEC(padapter);
@@ -4392,6 +4395,7 @@ inline s32 rtw_hal_set_FwMediaStatusRpt_range_cmd(_adapter *adapter, bool opmode
 	return rtw_hal_set_FwMediaStatusRpt_cmd(adapter, opmode, miracast, miracast_sink, role, macid, 1, macid_end);
 }
 
+void rtw_hal_set_FwRsvdPage_cmd(PADAPTER padapter, PRSVDPAGE_LOC rsvdpageloc);
 void rtw_hal_set_FwRsvdPage_cmd(PADAPTER padapter, PRSVDPAGE_LOC rsvdpageloc)
 {
 	struct	hal_ops *pHalFunc = &padapter->hal_func;
@@ -4536,6 +4540,7 @@ void rtw_hal_set_input_gpio(_adapter *padapter, u8 index)
 
 #endif
 
+void rtw_hal_set_FwAoacRsvdPage_cmd(PADAPTER padapter, PRSVDPAGE_LOC rsvdpageloc);
 void rtw_hal_set_FwAoacRsvdPage_cmd(PADAPTER padapter, PRSVDPAGE_LOC rsvdpageloc)
 {
 	struct	hal_ops *pHalFunc = &padapter->hal_func;
@@ -7669,6 +7674,8 @@ void rtw_hal_construct_NullFunctionData(
 	*pLength = pktlen;
 }
 
+void rtw_hal_construct_ProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength,
+				BOOLEAN bHideSSID);
 void rtw_hal_construct_ProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength,
 				BOOLEAN bHideSSID)
 {
@@ -11502,6 +11509,7 @@ s32 rtw_hal_set_wifi_btc_port_id_cmd(_adapter *adapter)
 #endif
 
 #define LPS_ACTIVE_TIMEOUT	50 /*number of times*/
+void rtw_lps_state_chk(_adapter *adapter, u8 ps_mode);
 void rtw_lps_state_chk(_adapter *adapter, u8 ps_mode)
 {
 	if (ps_mode == PS_MODE_ACTIVE) {
@@ -11973,6 +11981,7 @@ SetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value)
 }
 
 #ifdef CONFIG_BEAMFORMING
+u8 rtw_hal_query_txbfer_rf_num(_adapter *adapter);
 u8 rtw_hal_query_txbfer_rf_num(_adapter *adapter)
 {
 	struct registry_priv	*pregistrypriv = &adapter->registrypriv;
@@ -11998,6 +12007,7 @@ u8 rtw_hal_query_txbfer_rf_num(_adapter *adapter)
 		return 1;
 
 }
+u8 rtw_hal_query_txbfee_rf_num(_adapter *adapter);
 u8 rtw_hal_query_txbfee_rf_num(_adapter *adapter)
 {
 	struct registry_priv		*pregistrypriv = &adapter->registrypriv;
@@ -13001,6 +13011,7 @@ bool kfree_data_is_bb_gain_empty(struct kfree_data_t *data)
 }
 
 #ifdef CONFIG_USB_RX_AGGREGATION
+void rtw_set_usb_agg_by_mode_normal(_adapter *padapter, u8 cur_wireless_mode);
 void rtw_set_usb_agg_by_mode_normal(_adapter *padapter, u8 cur_wireless_mode)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
@@ -13069,6 +13080,7 @@ void rtw_set_usb_agg_by_mode_normal(_adapter *padapter, u8 cur_wireless_mode)
 	}
 }
 
+void rtw_set_usb_agg_by_mode_customer(_adapter *padapter, u8 cur_wireless_mode, u8 UsbDmaSize, u8 Legacy_UsbDmaSize);
 void rtw_set_usb_agg_by_mode_customer(_adapter *padapter, u8 cur_wireless_mode, u8 UsbDmaSize, u8 Legacy_UsbDmaSize)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
@@ -13096,6 +13108,7 @@ void rtw_set_usb_agg_by_mode_customer(_adapter *padapter, u8 cur_wireless_mode,
 	}
 }
 
+void rtw_set_usb_agg_by_mode(_adapter *padapter, u8 cur_wireless_mode);
 void rtw_set_usb_agg_by_mode(_adapter *padapter, u8 cur_wireless_mode)
 {
 #ifdef CONFIG_PLATFORM_NOVATEK_NT72668
@@ -14391,6 +14404,7 @@ void rtw_dump_phy_cap_by_phydmapi(void *sel, _adapter *adapter)
 	#endif
 }
 #else
+void rtw_dump_phy_cap_by_hal(void *sel, _adapter *adapter);
 void rtw_dump_phy_cap_by_hal(void *sel, _adapter *adapter)
 {
 	u8 phy_cap = _FALSE;
diff --git a/drivers/staging/rtl8812au/hal/hal_com_phycfg.c b/drivers/staging/rtl8812au/hal/hal_com_phycfg.c
index ada38b221..5ca3b824e 100644
--- a/drivers/staging/rtl8812au/hal/hal_com_phycfg.c
+++ b/drivers/staging/rtl8812au/hal/hal_com_phycfg.c
@@ -610,6 +610,13 @@ static inline void hal_init_pg_txpwr_info_5g(_adapter *adapter, TxPowerInfo5G *p
 #define LOAD_PG_TXPWR_WARN_COND(_txpwr_src) (_txpwr_src > PG_TXPWR_SRC_PG_DATA)
 #endif
 
+u16 hal_load_pg_txpwr_info_path_2g(
+	_adapter *adapter,
+	TxPowerInfo24G	*pwr_info,
+	u32 path,
+	u8 txpwr_src,
+	const struct map_t *txpwr_map,
+	u16 pg_offset);
 u16 hal_load_pg_txpwr_info_path_2g(
 	_adapter *adapter,
 	TxPowerInfo24G	*pwr_info,
@@ -738,6 +745,13 @@ u16 hal_load_pg_txpwr_info_path_2g(
 	return offset;
 }
 
+u16 hal_load_pg_txpwr_info_path_5g(
+	_adapter *adapter,
+	TxPowerInfo5G	*pwr_info,
+	u32 path,
+	u8 txpwr_src,
+	const struct map_t *txpwr_map,
+	u16 pg_offset);
 u16 hal_load_pg_txpwr_info_path_5g(
 	_adapter *adapter,
 	TxPowerInfo5G	*pwr_info,
@@ -897,6 +911,13 @@ u16 hal_load_pg_txpwr_info_path_5g(
 	return offset;
 }
 
+void hal_load_pg_txpwr_info(
+	_adapter *adapter,
+	TxPowerInfo24G *pwr_info_2g,
+	TxPowerInfo5G *pwr_info_5g,
+	u8 *pg_data,
+	BOOLEAN AutoLoadFail
+);
 void hal_load_pg_txpwr_info(
 	_adapter *adapter,
 	TxPowerInfo24G *pwr_info_2g,
@@ -1317,6 +1338,12 @@ void dump_hal_txpwr_info_5g(void *sel, _adapter *adapter, u8 rfpath_num, u8 max_
 *
 * Return dBm or -1 for undefined
 */
+s8 rtw_regsty_get_target_tx_power(
+	IN	PADAPTER		Adapter,
+	IN	u8				Band,
+	IN	u8				RfPath,
+	IN	RATE_SECTION	RateSection
+);
 s8 rtw_regsty_get_target_tx_power(
 	IN	PADAPTER		Adapter,
 	IN	u8				Band,
@@ -1361,6 +1388,7 @@ s8 rtw_regsty_get_target_tx_power(
 	return value;
 }
 
+bool rtw_regsty_chk_target_tx_power_valid(_adapter *adapter);
 bool rtw_regsty_chk_target_tx_power_valid(_adapter *adapter)
 {
 	struct hal_spec_t *hal_spec = GET_HAL_SPEC(adapter);
@@ -1441,6 +1469,14 @@ PHY_GetTxPowerByRateBase(
 	return value;
 }
 
+VOID
+phy_SetTxPowerByRateBase(
+	IN	PADAPTER		Adapter,
+	IN	u8				Band,
+	IN	u8				RfPath,
+	IN	RATE_SECTION	RateSection,
+	IN	u8				Value
+);
 VOID
 phy_SetTxPowerByRateBase(
 	IN	PADAPTER		Adapter,
@@ -1558,6 +1594,10 @@ static void phy_txpwr_by_rate_chk_for_path_dup(_adapter *adapter)
 	}
 }
 
+VOID
+phy_StoreTxPowerByRateBase(
+	IN	PADAPTER	pAdapter
+);
 VOID
 phy_StoreTxPowerByRateBase(
 	IN	PADAPTER	pAdapter
@@ -1964,6 +2004,15 @@ PHY_GetRateValuesOfTxPowerByRate(
 	};
 }
 
+void
+PHY_StoreTxPowerByRateNew(
+	IN	PADAPTER	pAdapter,
+	IN	u32			Band,
+	IN	u32			RfPath,
+	IN	u32			RegAddr,
+	IN	u32			BitMask,
+	IN	u32			Data
+);
 void
 PHY_StoreTxPowerByRateNew(
 	IN	PADAPTER	pAdapter,
@@ -2032,6 +2081,10 @@ phy_store_tx_power_by_rate(
 
 }
 
+VOID
+phy_ConvertTxPowerByRateInDbmToRelativeValues(
+	IN	PADAPTER	pAdapter
+);
 VOID
 phy_ConvertTxPowerByRateInDbmToRelativeValues(
 	IN	PADAPTER	pAdapter
@@ -2162,6 +2215,11 @@ phy_set_tx_power_index_by_rate_section(
 	return;
 }
 
+BOOLEAN
+phy_GetChnlIndex(
+	IN	u8	Channel,
+	OUT u8	*ChannelIdx
+);
 BOOLEAN
 phy_GetChnlIndex(
 	IN	u8	Channel,
@@ -3524,6 +3582,11 @@ static void phy_txpwr_lmt_post_hdl(_adapter *adapter)
 	_exit_critical_mutex(&rfctl->txpwr_lmt_mutex, &irqL);
 }
 
+BOOLEAN
+GetS1ByteIntegerFromStringInDecimal(
+	IN		char	*str,
+	IN OUT	s8		*val
+);
 BOOLEAN
 GetS1ByteIntegerFromStringInDecimal(
 	IN		char	*str,
@@ -4243,6 +4306,11 @@ phy_ConfigBBWithParaFile(
 	return rtStatus;
 }
 
+VOID
+phy_DecryptBBPgParaFile(
+	PADAPTER		Adapter,
+	char			*buffer
+);
 VOID
 phy_DecryptBBPgParaFile(
 	PADAPTER		Adapter,
@@ -4285,6 +4353,11 @@ phy_DecryptBBPgParaFile(
 #define DBG_TXPWR_BY_RATE_FILE_PARSE 0
 #endif
 
+int
+phy_ParseBBPgParaFile(
+	PADAPTER		Adapter,
+	char			*buffer
+);
 int
 phy_ParseBBPgParaFile(
 	PADAPTER		Adapter,
@@ -4714,6 +4787,16 @@ PHY_ConfigRFWithParaFile(
 	return rtStatus;
 }
 
+VOID
+initDeltaSwingIndexTables(
+	PADAPTER	Adapter,
+	char		*Band,
+	char		*Path,
+	char		*Sign,
+	char		*Channel,
+	char		*Rate,
+	char		*Data
+);
 VOID
 initDeltaSwingIndexTables(
 	PADAPTER	Adapter,
diff --git a/drivers/staging/rtl8812au/hal/hal_dm.c b/drivers/staging/rtl8812au/hal/hal_dm.c
index 0df8f64eb..1236b51ad 100644
--- a/drivers/staging/rtl8812au/hal/hal_dm.c
+++ b/drivers/staging/rtl8812au/hal/hal_dm.c
@@ -17,7 +17,8 @@
 #include <hal_data.h>
 
 /* A mapping from HalData to ODM. */
-enum odm_board_type boardType(u8 InterfaceSel)
+enum odm_board_type boardType(u8 InterfaceSel);
+enum odm_board_type boardType(u8 InterfaceSel)
 {
 	enum odm_board_type        board	= ODM_BOARD_DEFAULT;
 
@@ -94,6 +95,7 @@ void rtw_phydm_iqk_trigger(_adapter *adapter)
 }
 #endif
 
+void rtw_phydm_iqk_trigger_dbg(_adapter *adapter, bool recovery, bool clear, bool segment);
 void rtw_phydm_iqk_trigger_dbg(_adapter *adapter, bool recovery, bool clear, bool segment)
 {
 	struct dm_struct *p_dm_odm = adapter_to_phydm(adapter);
@@ -104,6 +106,7 @@ void rtw_phydm_iqk_trigger_dbg(_adapter *adapter, bool recovery, bool clear, boo
 		halrf_iqk_trigger(p_dm_odm, recovery);
 #endif
 }
+void rtw_phydm_lck_trigger(_adapter *adapter);
 void rtw_phydm_lck_trigger(_adapter *adapter)
 {
 	struct dm_struct *p_dm_odm = adapter_to_phydm(adapter);
@@ -162,6 +165,7 @@ void rtw_hal_update_param_init_fw_offload_cap(_adapter *adapter)
 }
 #endif
 
+void record_ra_info(void *p_dm_void, u8 macid, struct cmn_sta_info *p_sta, u64 ra_mask);
 void record_ra_info(void *p_dm_void, u8 macid, struct cmn_sta_info *p_sta, u64 ra_mask)
 {
 	struct dm_struct *p_dm = (struct dm_struct *)p_dm_void;
@@ -285,6 +289,7 @@ void rtw_phydm_tdmadig(_adapter *adapter, u8 state)
 	}
 }
 #endif/*CONFIG_TDMADIG*/
+void rtw_phydm_ops_func_init(struct dm_struct *p_phydm);
 void rtw_phydm_ops_func_init(struct dm_struct *p_phydm)
 {
 	struct ra_table *p_ra_t = &p_phydm->dm_ra_table;
diff --git a/drivers/staging/rtl8812au/hal/hal_intf.c b/drivers/staging/rtl8812au/hal/hal_intf.c
index 66a2954c5..de72c9612 100644
--- a/drivers/staging/rtl8812au/hal/hal_intf.c
+++ b/drivers/staging/rtl8812au/hal/hal_intf.c
@@ -260,6 +260,7 @@ void rtw_hal_power_off(_adapter *padapter)
 }
 
 
+void rtw_hal_init_opmode(_adapter *padapter);
 void rtw_hal_init_opmode(_adapter *padapter)
 {
 	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType = Ndis802_11InfrastructureMax;
@@ -639,6 +640,7 @@ void	rtw_hal_free_recv_priv(_adapter *padapter)
 	padapter->hal_func.free_recv_priv(padapter);
 }
 
+void rtw_sta_ra_registed(_adapter *padapter, struct sta_info *psta);
 void rtw_sta_ra_registed(_adapter *padapter, struct sta_info *psta)
 {
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
diff --git a/drivers/staging/rtl8812au/hal/hal_mp.c b/drivers/staging/rtl8812au/hal/hal_mp.c
index 7960556f2..2d2af16c8 100644
--- a/drivers/staging/rtl8812au/hal/hal_mp.c
+++ b/drivers/staging/rtl8812au/hal/hal_mp.c
@@ -373,6 +373,7 @@ void hal_mpt_SetBandwidth(PADAPTER pAdapter)
 
 }
 
+void mpt_SetTxPower_Old(PADAPTER pAdapter, MPT_TXPWR_DEF Rate, u8 *pTxPower);
 void mpt_SetTxPower_Old(PADAPTER pAdapter, MPT_TXPWR_DEF Rate, u8 *pTxPower)
 {
 	switch (Rate) {
@@ -431,6 +432,12 @@ void mpt_SetTxPower_Old(PADAPTER pAdapter, MPT_TXPWR_DEF Rate, u8 *pTxPower)
 	RTW_INFO("<===mpt_SetTxPower_Old()\n");
 }
 
+void
+mpt_SetTxPower(
+	PADAPTER		pAdapter,
+	MPT_TXPWR_DEF	Rate,
+	pu1Byte	pTxPower
+);
 void
 mpt_SetTxPower(
 	PADAPTER		pAdapter,
@@ -603,6 +610,7 @@ void hal_mpt_SetDataRate(PADAPTER pAdapter)
 #define RF_PATH_AB	22
 
 #ifdef CONFIG_RTL8814A
+VOID mpt_ToggleIG_8814A(PADAPTER	pAdapter);
 VOID mpt_ToggleIG_8814A(PADAPTER	pAdapter)
 {
 	u1Byte Path = 0;
@@ -632,6 +640,7 @@ VOID mpt_ToggleIG_8814A(PADAPTER	pAdapter)
 
 }
 
+VOID mpt_SetRFPath_8814A(PADAPTER	pAdapter);
 VOID mpt_SetRFPath_8814A(PADAPTER	pAdapter)
 {
 
@@ -866,6 +875,11 @@ VOID mpt_SetRFPath_8814A(PADAPTER	pAdapter)
 #endif /* CONFIG_RTL8814A */
 #if defined(CONFIG_RTL8814A) || defined(CONFIG_RTL8822B) || defined(CONFIG_RTL8821C) || defined(CONFIG_RTL8812A)
 VOID
+mpt_SetSingleTone_8814A(
+	IN	PADAPTER	pAdapter,
+	IN	BOOLEAN	bSingleTone,
+	IN	BOOLEAN	bEnPMacTx);
+VOID
 mpt_SetSingleTone_8814A(
 	IN	PADAPTER	pAdapter,
 	IN	BOOLEAN	bSingleTone,
@@ -1167,6 +1181,7 @@ void mpt_SetRFPath_8723D(PADAPTER pAdapter)
 }
 #endif
 
+VOID mpt_SetRFPath_819X(PADAPTER	pAdapter);
 VOID mpt_SetRFPath_819X(PADAPTER	pAdapter)
 {
 	HAL_DATA_TYPE			*pHalData	= GET_HAL_DATA(pAdapter);
diff --git a/drivers/staging/rtl8812au/hal/led/hal_usb_led.c b/drivers/staging/rtl8812au/hal/led/hal_usb_led.c
index 80f7a393c..16fd74bad 100644
--- a/drivers/staging/rtl8812au/hal/led/hal_usb_led.c
+++ b/drivers/staging/rtl8812au/hal/led/hal_usb_led.c
@@ -23,6 +23,10 @@
  *		It toggle off LED and schedule corresponding timer if necessary.
  *   */
 void
+SwLedBlink(
+	PLED_USB			pLed
+);
+void
 SwLedBlink(
 	PLED_USB			pLed
 )
@@ -112,6 +116,10 @@ SwLedBlink(
 	}
 }
 
+void
+SwLedBlink1(
+	PLED_USB			pLed
+);
 void
 SwLedBlink1(
 	PLED_USB			pLed
@@ -289,6 +297,10 @@ SwLedBlink1(
 
 }
 
+void
+SwLedBlink2(
+	PLED_USB			pLed
+);
 void
 SwLedBlink2(
 	PLED_USB			pLed
@@ -375,6 +387,10 @@ SwLedBlink2(
 
 }
 
+void
+SwLedBlink3(
+	PLED_USB			pLed
+);
 void
 SwLedBlink3(
 	PLED_USB			pLed
@@ -501,6 +517,10 @@ SwLedBlink3(
 }
 
 
+void
+SwLedBlink4(
+	PLED_USB			pLed
+);
 void
 SwLedBlink4(
 	PLED_USB			pLed
@@ -689,6 +709,10 @@ SwLedBlink4(
 
 }
 
+void
+SwLedBlink5(
+	PLED_USB			pLed
+);
 void
 SwLedBlink5(
 	PLED_USB			pLed
@@ -779,6 +803,10 @@ SwLedBlink5(
 
 }
 
+void
+SwLedBlink6(
+	PLED_USB			pLed
+);
 void
 SwLedBlink6(
 	PLED_USB			pLed
@@ -797,6 +825,10 @@ SwLedBlink6(
 
 }
 
+void
+SwLedBlink7(
+	PLED_USB			pLed
+);
 void
 SwLedBlink7(
 	PLED_USB			pLed
@@ -886,6 +918,10 @@ SwLedBlink7(
 
 }
 
+void
+SwLedBlink8(
+	PLED_USB			pLed
+);
 void
 SwLedBlink8(
 	PLED_USB			pLed
@@ -905,6 +941,10 @@ SwLedBlink8(
 
 /* page added for Belkin AC950. 20120813 */
 void
+SwLedBlink9(
+	PLED_USB			pLed
+);
+void
 SwLedBlink9(
 	PLED_USB			pLed
 )
@@ -1141,6 +1181,10 @@ SwLedBlink9(
 
 /* page added for Netgear A6200V2. 20120827 */
 void
+SwLedBlink10(
+	PLED_USB			pLed
+);
+void
 SwLedBlink10(
 	PLED_USB			pLed
 )
@@ -1340,6 +1384,10 @@ SwLedBlink10(
 
 }
 
+void
+SwLedBlink11(
+	PLED_USB			pLed
+);
 void
 SwLedBlink11(
 	PLED_USB			pLed
@@ -1411,6 +1459,10 @@ SwLedBlink11(
 
 }
 
+void
+SwLedBlink12(
+	PLED_USB			pLed
+);
 void
 SwLedBlink12(
 	PLED_USB			pLed
@@ -1479,6 +1531,10 @@ SwLedBlink12(
 
 }
 
+VOID
+SwLedBlink13(
+	IN PLED_USB			pLed
+);
 VOID
 SwLedBlink13(
 	IN PLED_USB			pLed
@@ -1540,6 +1596,10 @@ SwLedBlink13(
 
 }
 
+VOID
+SwLedBlink14(
+	IN PLED_USB			pLed
+);
 VOID
 SwLedBlink14(
 	IN PLED_USB			pLed
@@ -1597,6 +1657,10 @@ SwLedBlink14(
 
 }
 
+VOID
+SwLedBlink15(
+	IN PLED_USB			pLed
+);
 VOID
 SwLedBlink15(
 	IN PLED_USB			pLed
@@ -2909,6 +2973,11 @@ SwLedControlMode6(
 
 /* Netgear, added by sinda, 2011/11/11 */
 void
+SwLedControlMode7(
+	PADAPTER			 Adapter,
+	LED_CTL_MODE		 LedAction
+);
+void
 SwLedControlMode7(
 	PADAPTER			 Adapter,
 	LED_CTL_MODE		 LedAction
@@ -3047,6 +3116,11 @@ SwLedControlMode7(
 
 }
 
+void
+SwLedControlMode8(
+	PADAPTER			Adapter,
+	LED_CTL_MODE		LedAction
+);
 void
 SwLedControlMode8(
 	PADAPTER			Adapter,
@@ -3085,6 +3159,11 @@ SwLedControlMode8(
 
 /* page added for Belkin AC950, 20120813 */
 void
+SwLedControlMode9(
+	IN	PADAPTER			Adapter,
+	IN	LED_CTL_MODE		LedAction
+);
+void
 SwLedControlMode9(
 	IN	PADAPTER			Adapter,
 	IN	LED_CTL_MODE		LedAction
@@ -3387,6 +3466,11 @@ SwLedControlMode9(
 
 /* page added for Netgear A6200V2, 20120827 */
 void
+SwLedControlMode10(
+	PADAPTER			Adapter,
+	LED_CTL_MODE		LedAction
+);
+void
 SwLedControlMode10(
 	PADAPTER			Adapter,
 	LED_CTL_MODE		LedAction
@@ -3585,6 +3669,11 @@ SwLedControlMode10(
 
 /* Edimax-ASUS, added by Page, 20121221 */
 void
+SwLedControlMode11(
+	PADAPTER			Adapter,
+	LED_CTL_MODE		LedAction
+);
+void
 SwLedControlMode11(
 	PADAPTER			Adapter,
 	LED_CTL_MODE		LedAction
@@ -3683,6 +3772,11 @@ SwLedControlMode11(
 
 /* page added for NEC */
 
+VOID
+SwLedControlMode12(
+	PADAPTER			Adapter,
+	LED_CTL_MODE		LedAction
+);
 VOID
 SwLedControlMode12(
 	PADAPTER			Adapter,
@@ -3764,6 +3858,11 @@ SwLedControlMode12(
 
 /* Maddest add for NETGEAR R6100 */
 
+VOID
+SwLedControlMode13(
+	IN	PADAPTER			Adapter,
+	IN	LED_CTL_MODE		LedAction
+);
 VOID
 SwLedControlMode13(
 	IN	PADAPTER			Adapter,
@@ -3910,6 +4009,11 @@ SwLedControlMode13(
 
 /* Maddest add for DNI Buffalo */
 
+VOID
+SwLedControlMode14(
+	IN	PADAPTER			Adapter,
+	IN	LED_CTL_MODE		LedAction
+);
 VOID
 SwLedControlMode14(
 	IN	PADAPTER			Adapter,
@@ -3969,6 +4073,11 @@ SwLedControlMode14(
 
 /* Maddest add for Dlink */
 
+VOID
+SwLedControlMode15(
+	IN	PADAPTER			Adapter,
+	IN	LED_CTL_MODE		LedAction
+);
 VOID
 SwLedControlMode15(
 	IN	PADAPTER			Adapter,
diff --git a/drivers/staging/rtl8812au/hal/phydm/halrf/halphyrf_ce.c b/drivers/staging/rtl8812au/hal/phydm/halrf/halphyrf_ce.c
index c8753e500..4443c7289 100644
--- a/drivers/staging/rtl8812au/hal/phydm/halrf/halphyrf_ce.c
+++ b/drivers/staging/rtl8812au/hal/phydm/halrf/halphyrf_ce.c
@@ -152,6 +152,7 @@ void odm_clear_txpowertracking_state(void *dm_void)
 	cali_info->modify_tx_agc_value_ofdm = 0;
 }
 
+void odm_get_tracking_table(void *dm_void, u8 thermal_value, u8 delta);
 void odm_get_tracking_table(void *dm_void, u8 thermal_value, u8 delta)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -352,6 +353,7 @@ void odm_get_tracking_table(void *dm_void, u8 thermal_value, u8 delta)
 	}
 }
 
+void odm_pwrtrk_method(void *dm_void);
 void odm_pwrtrk_method(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -858,6 +860,7 @@ u8 odm_get_right_chnl_place_for_iqk(u8 chnl)
 }
 #endif
 
+void odm_iq_calibrate(struct dm_struct *dm);
 void odm_iq_calibrate(struct dm_struct *dm)
 {
 	void *adapter = dm->adapter;
diff --git a/drivers/staging/rtl8812au/hal/phydm/halrf/halrf.c b/drivers/staging/rtl8812au/hal/phydm/halrf/halrf.c
index 32fd1f3db..09ab5bae9 100644
--- a/drivers/staging/rtl8812au/hal/phydm/halrf/halrf.c
+++ b/drivers/staging/rtl8812au/hal/phydm/halrf/halrf.c
@@ -1135,6 +1135,7 @@ u64 halrf_cmn_info_get(void *dm_void, u32 cmn_info)
 	return return_value;
 }
 
+void halrf_supportability_init_mp(void *dm_void);
 void halrf_supportability_init_mp(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1353,6 +1354,7 @@ halrf_iqk_init(
 }
 #endif
 
+void halrf_dack_trigger(void *dm_void);
 void halrf_dack_trigger(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1674,6 +1676,7 @@ void halrf_lck_trigger(void *dm_void)
 	}
 }
 
+void halrf_aac_check(struct dm_struct *dm);
 void halrf_aac_check(struct dm_struct *dm)
 {
 	switch (dm->support_ic_type) {
@@ -2052,6 +2055,7 @@ halrf_config_rfk_with_header_file(void *dm_void, u32 config_type)
 	return result;
 }
 
+void halrf_txgapk_trigger(void *dm_void);
 void halrf_txgapk_trigger(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_debug.c b/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_debug.c
index 85a7cb22b..4d61870d8 100644
--- a/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_debug.c
+++ b/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_debug.c
@@ -31,6 +31,7 @@
 #include "mp_precomp.h"
 #include "phydm_precomp.h"
 
+void halrf_basic_profile(void *dm_void, u32 *_used, char *output, u32 *_out_len);
 void halrf_basic_profile(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 {
 #ifdef CONFIG_PHYDM_DEBUG_FUNCTION
@@ -65,6 +66,8 @@ void halrf_basic_profile(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 #endif
 }
 
+void halrf_debug_trace(void *dm_void, char input[][16], u32 *_used,
+		       char *output, u32 *_out_len);
 void halrf_debug_trace(void *dm_void, char input[][16], u32 *_used,
 		       char *output, u32 *_out_len)
 {
diff --git a/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_kfree.c b/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_kfree.c
index cee13be26..773364310 100644
--- a/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_kfree.c
+++ b/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_kfree.c
@@ -32,6 +32,7 @@
 /*@<YuChen, 150720> Add for KFree Feature Requested by RF David.*/
 /*@This is a phydm API*/
 
+void phydm_set_kfree_to_rf_8814a(void *dm_void, u8 e_rf_path, u8 data);
 void phydm_set_kfree_to_rf_8814a(void *dm_void, u8 e_rf_path, u8 data)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -124,6 +125,7 @@ void phydm_set_kfree_to_rf_8814a(void *dm_void, u8 e_rf_path, u8 data)
 	}
 }
 
+void phydm_get_thermal_trim_offset_8821c(void *dm_void);
 void phydm_get_thermal_trim_offset_8821c(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -151,6 +153,7 @@ void phydm_get_thermal_trim_offset_8821c(void *dm_void)
 		       power_trim_info->thermal);
 }
 
+void phydm_get_power_trim_offset_8821c(void *dm_void);
 void phydm_get_power_trim_offset_8821c(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -188,6 +191,8 @@ void phydm_get_power_trim_offset_8821c(void *dm_void)
 	}
 }
 
+void phydm_set_kfree_to_rf_8821c(void *dm_void, u8 e_rf_path, boolean wlg_btg,
+				 u8 data);
 void phydm_set_kfree_to_rf_8821c(void *dm_void, u8 e_rf_path, boolean wlg_btg,
 				 u8 data)
 {
@@ -223,6 +228,7 @@ void phydm_set_kfree_to_rf_8821c(void *dm_void, u8 e_rf_path, boolean wlg_btg,
 	       odm_get_rf_reg(dm, e_rf_path, RF_0x65, s_gain_bmask));
 }
 
+void phydm_clear_kfree_to_rf_8821c(void *dm_void, u8 e_rf_path, u8 data);
 void phydm_clear_kfree_to_rf_8821c(void *dm_void, u8 e_rf_path, u8 data)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -252,6 +258,7 @@ void phydm_clear_kfree_to_rf_8821c(void *dm_void, u8 e_rf_path, u8 data)
 	       odm_get_rf_reg(dm, e_rf_path, RF_0x65, s_gain_bmask));
 }
 
+void phydm_get_thermal_trim_offset_8822b(void *dm_void);
 void phydm_get_thermal_trim_offset_8822b(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -279,6 +286,7 @@ void phydm_get_thermal_trim_offset_8822b(void *dm_void)
 		       power_trim_info->thermal);
 }
 
+void phydm_get_power_trim_offset_8822b(void *dm_void);
 void phydm_get_power_trim_offset_8822b(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -346,6 +354,7 @@ void phydm_get_power_trim_offset_8822b(void *dm_void)
 	}
 }
 
+void phydm_set_pa_bias_to_rf_8822b(void *dm_void, u8 e_rf_path, s8 tx_pa_bias);
 void phydm_set_pa_bias_to_rf_8822b(void *dm_void, u8 e_rf_path, s8 tx_pa_bias)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -405,6 +414,7 @@ void phydm_set_pa_bias_to_rf_8822b(void *dm_void, u8 e_rf_path, s8 tx_pa_bias)
 			      e_rf_path);
 }
 
+void phydm_get_pa_bias_offset_8822b(void *dm_void);
 void phydm_get_pa_bias_offset_8822b(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -450,6 +460,7 @@ void phydm_get_pa_bias_offset_8822b(void *dm_void)
 	}
 }
 
+void phydm_set_kfree_to_rf_8822b(void *dm_void, u8 e_rf_path, u8 data);
 void phydm_set_kfree_to_rf_8822b(void *dm_void, u8 e_rf_path, u8 data)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -470,6 +481,7 @@ void phydm_set_kfree_to_rf_8822b(void *dm_void, u8 e_rf_path, u8 data)
 			      BIT(15) | BIT(14))), e_rf_path);
 }
 
+void phydm_clear_kfree_to_rf_8822b(void *dm_void, u8 e_rf_path, u8 data);
 void phydm_clear_kfree_to_rf_8822b(void *dm_void, u8 e_rf_path, u8 data)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -497,6 +509,7 @@ void phydm_clear_kfree_to_rf_8822b(void *dm_void, u8 e_rf_path, u8 data)
 			      BIT(15) | BIT(14))), e_rf_path);
 }
 
+void phydm_get_thermal_trim_offset_8710b(void *dm_void);
 void phydm_get_thermal_trim_offset_8710b(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -524,6 +537,7 @@ void phydm_get_thermal_trim_offset_8710b(void *dm_void)
 		       power_trim_info->thermal);
 }
 
+void phydm_get_power_trim_offset_8710b(void *dm_void);
 void phydm_get_power_trim_offset_8710b(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -551,6 +565,7 @@ void phydm_get_power_trim_offset_8710b(void *dm_void)
 		       power_trim_info->bb_gain[0][0]);
 }
 
+void phydm_set_kfree_to_rf_8710b(void *dm_void, u8 e_rf_path, u8 data);
 void phydm_set_kfree_to_rf_8710b(void *dm_void, u8 e_rf_path, u8 data)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -565,6 +580,7 @@ void phydm_set_kfree_to_rf_8710b(void *dm_void, u8 e_rf_path, u8 data)
 			      BIT(15) | BIT(14))), e_rf_path);
 }
 
+void phydm_clear_kfree_to_rf_8710b(void *dm_void, u8 e_rf_path, u8 data);
 void phydm_clear_kfree_to_rf_8710b(void *dm_void, u8 e_rf_path, u8 data)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -581,6 +597,7 @@ void phydm_clear_kfree_to_rf_8710b(void *dm_void, u8 e_rf_path, u8 data)
 			      BIT(15) | BIT(14))), e_rf_path);
 }
 
+void phydm_get_thermal_trim_offset_8192f(void *dm_void);
 void phydm_get_thermal_trim_offset_8192f(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -608,6 +625,7 @@ void phydm_get_thermal_trim_offset_8192f(void *dm_void)
 		       power_trim_info->thermal);
 }
 
+void phydm_get_power_trim_offset_8192f(void *dm_void);
 void phydm_get_power_trim_offset_8192f(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -677,6 +695,8 @@ void phydm_get_power_trim_offset_8192f(void *dm_void)
 	}
 }
 
+void phydm_set_kfree_to_rf_8192f(void *dm_void, u8 e_rf_path, u8 channel_idx,
+				 u8 data);
 void phydm_set_kfree_to_rf_8192f(void *dm_void, u8 e_rf_path, u8 channel_idx,
 				 u8 data)
 {
@@ -765,6 +785,7 @@ void phydm_clear_kfree_to_rf_8192f(void *dm_void, u8 e_rf_path, u8 data)
 */
 #endif
 
+void phydm_get_thermal_trim_offset_8198f(void *dm_void);
 void phydm_get_thermal_trim_offset_8198f(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -792,6 +813,7 @@ void phydm_get_thermal_trim_offset_8198f(void *dm_void)
 		       power_trim_info->thermal);
 }
 
+void phydm_get_power_trim_offset_8198f(void *dm_void);
 void phydm_get_power_trim_offset_8198f(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -843,6 +865,7 @@ void phydm_get_power_trim_offset_8198f(void *dm_void)
 	}
 }
 
+void phydm_set_kfree_to_rf_8198f(void *dm_void, u8 e_rf_path, u8 data);
 void phydm_set_kfree_to_rf_8198f(void *dm_void, u8 e_rf_path, u8 data)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -885,6 +908,7 @@ void phydm_set_kfree_to_rf_8198f(void *dm_void, u8 e_rf_path, u8 data)
 
 }
 
+void phydm_clear_kfree_to_rf_8198f(void *dm_void, u8 e_rf_path, u8 data);
 void phydm_clear_kfree_to_rf_8198f(void *dm_void, u8 e_rf_path, u8 data)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -930,6 +954,7 @@ void phydm_clear_kfree_to_rf_8198f(void *dm_void, u8 e_rf_path, u8 data)
 }
 
 
+void phydm_set_kfree_to_rf(void *dm_void, u8 e_rf_path, u8 data);
 void phydm_set_kfree_to_rf(void *dm_void, u8 e_rf_path, u8 data)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1048,6 +1073,7 @@ s8 phydm_get_thermal_offset(void *dm_void)
 		return 0;
 }
 
+void phydm_do_kfree(void *dm_void, u8 channel_to_sw);
 void phydm_do_kfree(void *dm_void, u8 channel_to_sw)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_powertracking_ce.c b/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_powertracking_ce.c
index 55ec7bf16..32671c854 100644
--- a/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_powertracking_ce.c
+++ b/drivers/staging/rtl8812au/hal/phydm/halrf/halrf_powertracking_ce.c
@@ -592,6 +592,7 @@ void odm_txpowertracking_init(void *dm_void)
 	odm_txpowertracking_thermal_meter_init(dm);
 }
 
+u8 get_swing_index(void *dm_void);
 u8 get_swing_index(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -642,6 +643,7 @@ u8 get_swing_index(void *dm_void)
 	return i;
 }
 
+u8 get_cck_swing_index(void *dm_void);
 u8 get_cck_swing_index(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8812a/halrf_8812a_ce.c b/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8812a/halrf_8812a_ce.c
index cebb7265d..a66721465 100644
--- a/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8812a/halrf_8812a_ce.c
+++ b/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8812a/halrf_8812a_ce.c
@@ -428,6 +428,8 @@ void configure_txpower_track_8812a(struct txpwrtrack_cfg *config)
 #define BW_40M 1
 #define BW_80M 2
 
+void _iqk_rx_fill_iqc_8812a(struct dm_struct *dm, enum rf_path path,
+			    unsigned int RX_X, unsigned int RX_Y);
 void _iqk_rx_fill_iqc_8812a(struct dm_struct *dm, enum rf_path path,
 			    unsigned int RX_X, unsigned int RX_Y)
 {
@@ -473,6 +475,8 @@ void _iqk_rx_fill_iqc_8812a(struct dm_struct *dm, enum rf_path path,
 	};
 }
 
+void _iqk_tx_fill_iqc_8812a(struct dm_struct *dm, enum rf_path path,
+			    unsigned int TX_X, unsigned int TX_Y);
 void _iqk_tx_fill_iqc_8812a(struct dm_struct *dm, enum rf_path path,
 			    unsigned int TX_X, unsigned int TX_Y)
 {
@@ -518,6 +522,8 @@ void _iqk_tx_fill_iqc_8812a(struct dm_struct *dm, enum rf_path path,
 	};
 }
 
+void _iqk_backup_mac_bb_8812a(struct dm_struct *dm, u32 *MACBB_backup,
+			      u32 *backup_macbb_reg, u32 MACBB_NUM);
 void _iqk_backup_mac_bb_8812a(struct dm_struct *dm, u32 *MACBB_backup,
 			      u32 *backup_macbb_reg, u32 MACBB_NUM)
 {
@@ -529,6 +535,8 @@ void _iqk_backup_mac_bb_8812a(struct dm_struct *dm, u32 *MACBB_backup,
 
 	RF_DBG(dm, DBG_RF_IQK, "BackupMacBB Success!!!!\n");
 }
+void _iqk_backup_rf_8812a(struct dm_struct *dm, u32 *RFA_backup,
+			  u32 *RFB_backup, u32 *backup_rf_reg, u32 RF_NUM);
 void _iqk_backup_rf_8812a(struct dm_struct *dm, u32 *RFA_backup,
 			  u32 *RFB_backup, u32 *backup_rf_reg, u32 RF_NUM)
 {
@@ -541,6 +549,8 @@ void _iqk_backup_rf_8812a(struct dm_struct *dm, u32 *RFA_backup,
 	}
 	RF_DBG(dm, DBG_RF_IQK, "BackupRF Success!!!!\n");
 }
+void _iqk_backup_afe_8812a(struct dm_struct *dm, u32 *AFE_backup,
+			   u32 *backup_afe_reg, u32 AFE_NUM);
 void _iqk_backup_afe_8812a(struct dm_struct *dm, u32 *AFE_backup,
 			   u32 *backup_afe_reg, u32 AFE_NUM)
 {
@@ -551,6 +561,8 @@ void _iqk_backup_afe_8812a(struct dm_struct *dm, u32 *AFE_backup,
 		AFE_backup[i] = odm_read_4byte(dm, backup_afe_reg[i]);
 	RF_DBG(dm, DBG_RF_IQK, "BackupAFE Success!!!!\n");
 }
+void _iqk_restore_mac_bb_8812a(struct dm_struct *dm, u32 *MACBB_backup,
+			       u32 *backup_macbb_reg, u32 MACBB_NUM);
 void _iqk_restore_mac_bb_8812a(struct dm_struct *dm, u32 *MACBB_backup,
 			       u32 *backup_macbb_reg, u32 MACBB_NUM)
 {
@@ -561,6 +573,8 @@ void _iqk_restore_mac_bb_8812a(struct dm_struct *dm, u32 *MACBB_backup,
 		odm_write_4byte(dm, backup_macbb_reg[i], MACBB_backup[i]);
 	RF_DBG(dm, DBG_RF_IQK, "RestoreMacBB Success!!!!\n");
 }
+void _iqk_restore_rf_8812a(struct dm_struct *dm, enum rf_path path,
+			   u32 *backup_rf_reg, u32 *RF_backup, u32 RF_REG_NUM);
 void _iqk_restore_rf_8812a(struct dm_struct *dm, enum rf_path path,
 			   u32 *backup_rf_reg, u32 *RF_backup, u32 RF_REG_NUM)
 {
@@ -583,6 +597,8 @@ void _iqk_restore_rf_8812a(struct dm_struct *dm, enum rf_path path,
 		break;
 	}
 }
+void _iqk_restore_afe_8812a(struct dm_struct *dm, u32 *AFE_backup,
+			    u32 *backup_afe_reg, u32 AFE_NUM);
 void _iqk_restore_afe_8812a(struct dm_struct *dm, u32 *AFE_backup,
 			    u32 *backup_afe_reg, u32 AFE_NUM)
 {
@@ -616,6 +632,7 @@ void _iqk_restore_afe_8812a(struct dm_struct *dm, u32 *AFE_backup,
 	RF_DBG(dm, DBG_RF_IQK, "RestoreAFE Success!!!!\n");
 }
 
+void _iqk_configure_mac_8812a(struct dm_struct *dm);
 void _iqk_configure_mac_8812a(struct dm_struct *dm)
 {
 	/* ========MAC register setting======== */
@@ -629,6 +646,7 @@ void _iqk_configure_mac_8812a(struct dm_struct *dm)
 
 #define cal_num 10
 
+void _iqk_tx_8812a(struct dm_struct *dm, u8 chnl_idx);
 void _iqk_tx_8812a(struct dm_struct *dm, u8 chnl_idx)
 {
 	u8 delay_count, cal = 0;
@@ -1122,6 +1140,7 @@ void _iqk_tx_8812a(struct dm_struct *dm, u8 chnl_idx)
 #define RF_REG_NUM 3
 
 /* Maintained by BB James. */
+void _phy_iq_calibrate_8812a(struct dm_struct *dm, u8 channel);
 void _phy_iq_calibrate_8812a(struct dm_struct *dm, u8 channel)
 {
 	u32 MACBB_backup[MACBB_REG_NUM], AFE_backup[AFE_REG_NUM] = {0}, RFA_backup[RF_REG_NUM] = {0}, RFB_backup[RF_REG_NUM] = {0};
@@ -1153,6 +1172,7 @@ void _phy_iq_calibrate_8812a(struct dm_struct *dm, u8 channel)
 	_iqk_restore_mac_bb_8812a(dm, MACBB_backup, backup_macbb_reg, MACBB_REG_NUM);
 }
 
+void _phy_lc_calibrate_8812a(struct dm_struct *dm, boolean is2T);
 void _phy_lc_calibrate_8812a(struct dm_struct *dm, boolean is2T)
 {
 	u32 /*rf_amode=0, rf_bmode=0,*/ lc_cal = 0, tmp = 0;
@@ -1218,6 +1238,7 @@ void _phy_lc_calibrate_8812a(struct dm_struct *dm, boolean is2T)
 		*/
 }
 
+void phy_reload_iqk_setting_8812a(struct dm_struct *dm, u8 channel);
 void phy_reload_iqk_setting_8812a(struct dm_struct *dm, u8 channel)
 {
 	struct dm_rf_calibration_struct *cali_info = &(dm->rf_calibrate_info);
@@ -1243,6 +1264,7 @@ void phy_reload_iqk_setting_8812a(struct dm_struct *dm, u8 channel)
 	odm_set_bb_reg(dm, R_0xe10, 0x03ff0000, (cali_info->iqk_matrix_reg_setting[chnl_idx].value[*dm->band_width][3] & 0x7ff) >> 1);
 }
 
+void phy_reset_iqk_result_8812a(struct dm_struct *dm);
 void phy_reset_iqk_result_8812a(struct dm_struct *dm)
 {
 	odm_set_bb_reg(dm, R_0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
@@ -1257,6 +1279,7 @@ void phy_reset_iqk_result_8812a(struct dm_struct *dm)
 	odm_set_bb_reg(dm, R_0xe10, 0x000003ff, 0x100);
 }
 
+void _phy_iq_calibrate_by_fw_8812a(struct dm_struct *dm);
 void _phy_iq_calibrate_by_fw_8812a(struct dm_struct *dm)
 {
 	u8 iqk_cmd[3] = {*dm->channel, 0x0, 0x0};
diff --git a/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8814a/halrf_8814a_ce.c b/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8814a/halrf_8814a_ce.c
index 09c65ed3f..41ce0a6dd 100644
--- a/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8814a/halrf_8814a_ce.c
+++ b/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8814a/halrf_8814a_ce.c
@@ -400,6 +400,11 @@ void configure_txpower_track_8814a(
 	pConfig->get_delta_swing_table8814only = GetDeltaSwingTable_8814A_PathCD;
 }
 
+VOID	
+_phy_lc_calibrate_8814a(
+	IN struct dm_struct	*		pDM_Odm,
+	IN	BOOLEAN		is2T
+	);
 VOID	
 _phy_lc_calibrate_8814a(
 	IN struct dm_struct	*		pDM_Odm,
@@ -513,6 +518,10 @@ PHY_DPCalibrate_8814A(
 }
 
 
+BOOLEAN 
+phy_QueryRFPathSwitch_8814A(
+	IN	PADAPTER	pAdapter
+	);
 BOOLEAN 
 phy_QueryRFPathSwitch_8814A(
 	IN	PADAPTER	pAdapter
diff --git a/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8814a/halrf_iqk_8814a.c b/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8814a/halrf_iqk_8814a.c
index e019df35a..f8a7a020d 100644
--- a/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8814a/halrf_iqk_8814a.c
+++ b/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8814a/halrf_iqk_8814a.c
@@ -63,6 +63,14 @@ void DoIQK_8814A(
 #endif
 //1 7.	IQK
 
+VOID 
+_IQK_BackupMacBB_8814A(
+	IN struct dm_struct    *	pDM_Odm,
+	u32*		MAC_backup,
+	u32*		BB_backup,
+	u32*		Backup_MAC_REG,
+	u32*		Backup_BB_REG
+	);
 VOID 
 _IQK_BackupMacBB_8814A(
 	IN struct dm_struct    *	pDM_Odm,
@@ -90,7 +98,13 @@ _IQK_BackupRF_8814A(
 	IN struct dm_struct    *	pDM_Odm,
 	u32		RF_backup[][4],
 	u32*		Backup_RF_REG
-	)	
+	);
+VOID
+_IQK_BackupRF_8814A(
+	IN struct dm_struct    *	pDM_Odm,
+	u32		RF_backup[][4],
+	u32*		Backup_RF_REG
+	)
 {
 	u32 i;
 	//Save RF Parameters
@@ -105,6 +119,11 @@ _IQK_BackupRF_8814A(
 }
 
 
+VOID
+_IQK_AFESetting_8814A(
+	IN struct dm_struct    *	pDM_Odm,
+	IN boolean		Do_IQK
+	);
 VOID
 _IQK_AFESetting_8814A(
 	IN struct dm_struct    *	pDM_Odm,
@@ -155,7 +174,15 @@ _IQK_RestoreMacBB_8814A(
 	u32*		BB_backup,
 	u32*		Backup_MAC_REG, 
 	u32*		Backup_BB_REG
-	)	
+	);
+VOID
+_IQK_RestoreMacBB_8814A(
+	IN struct dm_struct    *		pDM_Odm,
+	u32*		MAC_backup,
+	u32*		BB_backup,
+	u32*		Backup_MAC_REG, 
+	u32*		Backup_BB_REG
+	)
 {
 	u32 i;
 	//Reload MacBB Parameters 
@@ -168,6 +195,12 @@ _IQK_RestoreMacBB_8814A(
     	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("RestoreMacBB Success!!!!\n"));
 }
 
+VOID
+_IQK_RestoreRF_8814A(
+	IN struct dm_struct    *			pDM_Odm,
+	u32*			Backup_RF_REG,
+	u32 			RF_backup[][4]
+	);
 VOID
 _IQK_RestoreRF_8814A(
 	IN struct dm_struct    *			pDM_Odm,
@@ -193,6 +226,10 @@ _IQK_RestoreRF_8814A(
 	
 }
 
+VOID 
+PHY_ResetIQKResult_8814A(
+	IN	struct dm_struct    *	pDM_Odm
+);
 VOID 
 PHY_ResetIQKResult_8814A(
 	IN	struct dm_struct    *	pDM_Odm
@@ -212,6 +249,10 @@ PHY_ResetIQKResult_8814A(
 	odm_write_4byte(pDM_Odm, 0x1a10, 0x100);
 }
 
+VOID 
+_IQK_ResetNCTL_8814A(
+	IN struct dm_struct    *	pDM_Odm
+);
 VOID 
 _IQK_ResetNCTL_8814A(
 	IN struct dm_struct    *	pDM_Odm
@@ -224,6 +265,10 @@ _IQK_ResetNCTL_8814A(
 	ODM_RT_TRACE(pDM_Odm, ODM_COMP_CALIBRATION, ODM_DBG_LOUD, ("ResetNCTL Success!!!!\n"));
 }
 
+VOID 
+_IQK_ConfigureMAC_8814A(
+	IN struct dm_struct    *		pDM_Odm
+	);
 VOID 
 _IQK_ConfigureMAC_8814A(
 	IN struct dm_struct    *		pDM_Odm
@@ -244,6 +289,10 @@ _IQK_ConfigureMAC_8814A(
 	odm_set_bb_reg(pDM_Odm, 0xcbc, 0xf, 0x0);
 }
 
+VOID
+_LOK_One_Shot(
+	IN	void*		pDM_VOID
+);
 VOID
 _LOK_One_Shot(
 	IN	void*		pDM_VOID
@@ -314,6 +363,10 @@ _LOK_One_Shot(
 		pIQK_info->lok_fail[0], pIQK_info->lok_fail[1], pIQK_info->lok_fail[2], pIQK_info->lok_fail[3]));
 }
 
+VOID
+_IQK_One_Shot(
+	IN	void*		pDM_VOID
+);
 VOID
 _IQK_One_Shot(
 	IN	void*		pDM_VOID
@@ -434,6 +487,11 @@ _IQK_One_Shot(
 	}
 }
 
+VOID
+_IQK_Tx_8814A(
+	IN struct dm_struct    *		pDM_Odm,
+	IN u8 chnlIdx
+	);
 VOID
 _IQK_Tx_8814A(
 	IN struct dm_struct    *		pDM_Odm,
@@ -469,6 +527,11 @@ _IQK_Tx_8814A(
 
 }
 
+VOID	
+_phy_iq_calibrate_8814a(
+	IN struct dm_struct    *		pDM_Odm,
+	IN u8		Channel
+	);
 VOID	
 _phy_iq_calibrate_8814a(
 	IN struct dm_struct    *		pDM_Odm,
diff --git a/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.c b/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.c
index b6491baf7..cc46c94e1 100644
--- a/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.c
+++ b/drivers/staging/rtl8812au/hal/phydm/halrf/rtl8821a/halrf_iqk_8821a_ce.c
@@ -37,6 +37,12 @@ void do_iqk_8821a(
 	halrf_iqk_trigger(dm, false);
 }
 #endif
+void _iqk_rx_fill_iqc_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	unsigned int			RX_X,
+	unsigned int			RX_Y
+);
 void _iqk_rx_fill_iqc_8821a(
 	struct dm_struct			*dm,
 	enum rf_path	path,
@@ -59,6 +65,12 @@ void _iqk_rx_fill_iqc_8821a(
 	};
 }
 
+void _iqk_tx_fill_iqc_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	unsigned int			TX_X,
+	unsigned int			TX_Y
+);
 void _iqk_tx_fill_iqc_8821a(
 	struct dm_struct			*dm,
 	enum rf_path	path,
@@ -84,6 +96,12 @@ void _iqk_tx_fill_iqc_8821a(
 	};
 }
 
+void _iqk_backup_mac_bb_8821a(
+	struct dm_struct	*dm,
+	u32		*MACBB_backup,
+	u32		*backup_macbb_reg,
+	u32		MACBB_NUM
+);
 void _iqk_backup_mac_bb_8821a(
 	struct dm_struct	*dm,
 	u32		*MACBB_backup,
@@ -100,6 +118,13 @@ void _iqk_backup_mac_bb_8821a(
 	PHYDM_DBG(dm, DBG_COMP_MCC, "BackupMacBB Success!!!!\n");
 }
 
+void _iqk_backup_rf_8821a(
+	struct dm_struct	*dm,
+	u32		*RFA_backup,
+	u32		*RFB_backup,
+	u32		*backup_rf_reg,
+	u32		RF_NUM
+);
 void _iqk_backup_rf_8821a(
 	struct dm_struct	*dm,
 	u32		*RFA_backup,
@@ -117,6 +142,12 @@ void _iqk_backup_rf_8821a(
 	PHYDM_DBG(dm, DBG_COMP_MCC, "BackupRF Success!!!!\n");
 }
 
+void _iqk_backup_afe_8821a(
+	struct dm_struct		*dm,
+	u32		*AFE_backup,
+	u32		*backup_afe_reg,
+	u32		AFE_NUM
+);
 void _iqk_backup_afe_8821a(
 	struct dm_struct		*dm,
 	u32		*AFE_backup,
@@ -132,6 +163,12 @@ void _iqk_backup_afe_8821a(
 	PHYDM_DBG(dm, DBG_COMP_MCC, "BackupAFE Success!!!!\n");
 }
 
+void _iqk_restore_mac_bb_8821a(
+	struct dm_struct		*dm,
+	u32		*MACBB_backup,
+	u32		*backup_macbb_reg,
+	u32		MACBB_NUM
+);
 void _iqk_restore_mac_bb_8821a(
 	struct dm_struct		*dm,
 	u32		*MACBB_backup,
@@ -147,6 +184,13 @@ void _iqk_restore_mac_bb_8821a(
 	PHYDM_DBG(dm, DBG_COMP_MCC, "RestoreMacBB Success!!!!\n");
 }
 
+void _iqk_restore_rf_8821a(
+	struct dm_struct			*dm,
+	enum rf_path	path,
+	u32				*backup_rf_reg,
+	u32				*RF_backup,
+	u32				RF_REG_NUM
+);
 void _iqk_restore_rf_8821a(
 	struct dm_struct			*dm,
 	enum rf_path	path,
@@ -172,6 +216,12 @@ void _iqk_restore_rf_8821a(
 	}
 }
 
+void _iqk_restore_afe_8821a(
+	struct dm_struct		*dm,
+	u32		*AFE_backup,
+	u32		*backup_afe_reg,
+	u32		AFE_NUM
+);
 void _iqk_restore_afe_8821a(
 	struct dm_struct		*dm,
 	u32		*AFE_backup,
@@ -197,6 +247,9 @@ void _iqk_restore_afe_8821a(
 	PHYDM_DBG(dm, DBG_COMP_MCC, "RestoreAFE Success!!!!\n");
 }
 
+void _iqk_configure_mac_8821a(
+	struct dm_struct		*dm
+);
 void _iqk_configure_mac_8821a(
 	struct dm_struct		*dm
 )
@@ -210,6 +263,10 @@ void _iqk_configure_mac_8821a(
 	odm_write_1byte(dm, 0xa07, 0xf);		/*		CCK RX path off */
 }
 
+void _iqk_tx_8821a(
+	struct dm_struct		*dm,
+	enum rf_path path
+);
 void _iqk_tx_8821a(
 	struct dm_struct		*dm,
 	enum rf_path path
@@ -680,6 +737,10 @@ void _iqk_tx_8821a(
 
 #if !(DM_ODM_SUPPORT_TYPE & ODM_AP)
 void
+_phy_iq_calibrate_by_fw_8821a(
+	struct dm_struct	*dm
+);
+void
 _phy_iq_calibrate_by_fw_8821a(
 	struct dm_struct	*dm
 )
@@ -714,6 +775,10 @@ _phy_iq_calibrate_by_fw_8821a(
 }
 #endif
 
+void
+_phy_iq_calibrate_8821a(
+	struct dm_struct		*dm
+);
 void
 _phy_iq_calibrate_8821a(
 	struct dm_struct		*dm
@@ -736,6 +801,10 @@ _phy_iq_calibrate_8821a(
 	_iqk_restore_mac_bb_8821a(dm, MACBB_backup, backup_macbb_reg, MACBB_REG_NUM_8821A);
 }
 
+void
+phy_reset_iqk_result_8821a(
+	struct dm_struct	*dm
+);
 void
 phy_reset_iqk_result_8821a(
 	struct dm_struct	*dm
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm.c b/drivers/staging/rtl8812au/hal/phydm/phydm.c
index 1e980630e..867e8a073 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm.c
@@ -38,6 +38,7 @@ const u16 phy_rate_table[] = {
 	13, 26, 39, 52, 78, 104, 117, 130 /*@MCS8~15*/
 };
 
+void phydm_traffic_load_decision(void *dm_void);
 void phydm_traffic_load_decision(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -109,6 +110,7 @@ void phydm_traffic_load_decision(void *dm_void)
 	#endif
 }
 
+void phydm_cck_new_agc_chk(struct dm_struct *dm);
 void phydm_cck_new_agc_chk(struct dm_struct *dm)
 {
 	dm->cck_new_agc = 0;
@@ -132,6 +134,7 @@ void phydm_cck_new_agc_chk(struct dm_struct *dm)
 }
 
 /*select 3 or 4 bit LNA */
+void phydm_cck_lna_bit_num_chk(struct dm_struct *dm);
 void phydm_cck_lna_bit_num_chk(struct dm_struct *dm)
 {
 	boolean report_type = 0;
@@ -177,6 +180,7 @@ void phydm_cck_lna_bit_num_chk(struct dm_struct *dm)
 		  dm->cck_agc_report_type);
 }
 
+void phydm_init_cck_setting(struct dm_struct *dm);
 void phydm_init_cck_setting(struct dm_struct *dm)
 {
 	u32 reg_tmp = 0;
@@ -200,6 +204,7 @@ void phydm_init_cck_setting(struct dm_struct *dm)
 	phydm_get_cck_rssi_table_from_reg(dm);
 }
 
+void phydm_init_hw_info_by_rfe(struct dm_struct *dm);
 void phydm_init_hw_info_by_rfe(struct dm_struct *dm)
 {
 #if (RTL8822B_SUPPORT == 1)
@@ -216,6 +221,7 @@ void phydm_init_hw_info_by_rfe(struct dm_struct *dm)
 #endif
 }
 
+void phydm_common_info_self_init(struct dm_struct *dm);
 void phydm_common_info_self_init(struct dm_struct *dm)
 {
 	u32 reg_tmp = 0;
@@ -298,6 +304,7 @@ void phydm_common_info_self_init(struct dm_struct *dm)
 	dm->pause_lv_table.lv_dig = PHYDM_PAUSE_RELEASE;
 }
 
+void phydm_cmn_sta_info_update(void *dm_void, u8 macid);
 void phydm_cmn_sta_info_update(void *dm_void, u8 macid)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -326,6 +333,7 @@ void phydm_cmn_sta_info_update(void *dm_void, u8 macid)
 	ra->is_noisy = dm->noisy_decision;
 }
 
+void phydm_common_info_self_update(struct dm_struct *dm);
 void phydm_common_info_self_update(struct dm_struct *dm)
 {
 	u8 sta_cnt = 0, num_active_client = 0;
@@ -431,6 +439,7 @@ void phydm_common_info_self_update(struct dm_struct *dm)
 	dm->phy_dbg_info.show_phy_sts_cnt = 0;
 }
 
+void phydm_common_info_self_reset(struct dm_struct *dm);
 void phydm_common_info_self_reset(struct dm_struct *dm)
 {
 	struct odm_phy_dbg_info		*dbg_t = &dm->phy_dbg_info;
@@ -474,6 +483,7 @@ phydm_get_structure(struct dm_struct *dm, u8 structure_type)
 	return structure;
 }
 
+void phydm_phy_info_update(struct dm_struct *dm);
 void phydm_phy_info_update(struct dm_struct *dm)
 {
 #if (RTL8822B_SUPPORT == 1)
@@ -482,6 +492,7 @@ void phydm_phy_info_update(struct dm_struct *dm)
 #endif
 }
 
+void phydm_hw_setting(struct dm_struct *dm);
 void phydm_hw_setting(struct dm_struct *dm)
 {
 #if (RTL8821A_SUPPORT == 1)
@@ -783,6 +794,7 @@ u64 phydm_supportability_init_win(
 #endif
 
 #if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+u64 phydm_supportability_init_ce(void *dm_void);
 u64 phydm_supportability_init_ce(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1401,6 +1413,7 @@ void phydm_fwoffload_ability_clear(struct dm_struct *dm,
 		  dm->fw_offload_ability);
 }
 
+void phydm_supportability_init(void *dm_void);
 void phydm_supportability_init(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1440,6 +1453,7 @@ void phydm_supportability_init(void *dm_void)
 		  dm->support_ic_type, *dm->mp_mode, dm->support_ability);
 }
 
+void phydm_rfe_init(void *dm_void);
 void phydm_rfe_init(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1970,6 +1984,7 @@ void phydm_pause_func_console(void *dm_void, char input[][16], u32 *_used,
 	*_out_len = out_len;
 }
 
+u8 phydm_stop_dm_watchdog_check(void *dm_void);
 u8 phydm_stop_dm_watchdog_check(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_adaptivity.c b/drivers/staging/rtl8812au/hal/phydm/phydm_adaptivity.c
index 086903624..e72e9d41d 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_adaptivity.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_adaptivity.c
@@ -111,6 +111,7 @@ phydm_soft_ap_special_set(void *dm_void)
 }
 #endif
 
+void phydm_dig_up_bound_lmt_en(void *dm_void);
 void phydm_dig_up_bound_lmt_en(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -140,6 +141,7 @@ void phydm_dig_up_bound_lmt_en(void *dm_void)
 		  adapt->igi_up_bound_lmt_cnt);
 }
 
+void phydm_check_adaptivity(void *dm_void);
 void phydm_check_adaptivity(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -174,6 +176,7 @@ void phydm_check_adaptivity(void *dm_void)
 #endif
 }
 
+void phydm_set_edcca_threshold(void *dm_void, s8 H2L, s8 L2H);
 void phydm_set_edcca_threshold(void *dm_void, s8 H2L, s8 L2H)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -190,6 +193,7 @@ void phydm_set_edcca_threshold(void *dm_void, s8 H2L, s8 L2H)
 	}
 }
 
+void phydm_mac_edcca_state(void *dm_void, enum phydm_mac_edcca_type state);
 void phydm_mac_edcca_state(void *dm_void, enum phydm_mac_edcca_type state)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -208,6 +212,7 @@ void phydm_mac_edcca_state(void *dm_void, enum phydm_mac_edcca_type state)
 	PHYDM_DBG(dm, DBG_ADPTVTY, "EDCCA enable state = %d\n", state);
 }
 
+void phydm_search_pwdb_lower_bound(void *dm_void);
 void phydm_search_pwdb_lower_bound(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -285,6 +290,8 @@ void phydm_search_pwdb_lower_bound(void *dm_void)
 	phydm_set_edcca_threshold(dm, 0x7f, 0x7f); /*resume to no link state*/
 }
 
+boolean
+phydm_re_search_condition(void *dm_void);
 boolean
 phydm_re_search_condition(void *dm_void)
 {
@@ -298,6 +305,7 @@ phydm_re_search_condition(void *dm_void)
 		return false;
 }
 
+void phydm_set_l2h_th_ini(void *dm_void);
 void phydm_set_l2h_th_ini(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -317,6 +325,7 @@ void phydm_set_l2h_th_ini(void *dm_void)
 	}
 }
 
+void phydm_set_forgetting_factor(void *dm_void);
 void phydm_set_forgetting_factor(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -327,6 +336,7 @@ void phydm_set_forgetting_factor(void *dm_void)
 		odm_set_bb_reg(dm, R_0x83c, BIT(31) | BIT(30) | BIT(29), 0x7);
 }
 
+void phydm_set_pwdb_mode(void *dm_void);
 void phydm_set_pwdb_mode(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -445,6 +455,7 @@ void phydm_set_edcca_val(void *dm_void, u32 *val_buf, u8 val_len)
 	phydm_set_edcca_threshold(dm, (s8)val_buf[1], (s8)val_buf[0]);
 }
 
+boolean phydm_edcca_abort(void *dm_void);
 boolean phydm_edcca_abort(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_adc_sampling.c b/drivers/staging/rtl8812au/hal/phydm/phydm_adc_sampling.c
index d2278560e..903aa635b 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_adc_sampling.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_adc_sampling.c
@@ -43,6 +43,8 @@
 
 #if (DM_ODM_SUPPORT_TYPE & (ODM_WIN | ODM_CE | ODM_AP))
 boolean
+phydm_la_buffer_allocate(void *dm_void);
+boolean
 phydm_la_buffer_allocate(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -77,6 +79,7 @@ phydm_la_buffer_allocate(void *dm_void)
 }
 #endif
 
+void phydm_la_get_tx_pkt_buf(void *dm_void);
 void phydm_la_get_tx_pkt_buf(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -260,6 +263,7 @@ void phydm_la_get_tx_pkt_buf(void *dm_void)
 	#endif
 }
 
+void phydm_la_mode_set_mac_iq_dump(void *dm_void, boolean en_fake_trig);
 void phydm_la_mode_set_mac_iq_dump(void *dm_void, boolean en_fake_trig)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -327,6 +331,7 @@ void phydm_la_mode_set_mac_iq_dump(void *dm_void, boolean en_fake_trig)
 	#endif
 }
 
+void phydm_adc_smp_start(void *dm_void);
 void phydm_adc_smp_start(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_api.c b/drivers/staging/rtl8812au/hal/phydm/phydm_api.c
index f84279c39..f16510291 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_api.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_api.c
@@ -105,6 +105,7 @@ void phydm_ant_weight_dbg(void *dm_void, char input[][16], u32 *_used,
 }
 #endif
 
+void phydm_iq_gen_en(void *dm_void);
 void phydm_iq_gen_en(void *dm_void)
 {
 #ifdef PHYDM_COMPILE_IC_2SS
@@ -160,6 +161,7 @@ void phydm_iq_gen_en(void *dm_void)
 #endif
 }
 
+void phydm_dis_cdd(void *dm_void);
 void phydm_dis_cdd(void *dm_void)
 {
 #ifdef PHYDM_COMPILE_IC_2SS
@@ -310,6 +312,7 @@ void phydm_trx_antenna_setting_init(void *dm_void, u8 num_rf_path)
 		  __func__, dm->tx_ant_status, dm->rx_ant_status);
 }
 
+void phydm_config_ofdm_tx_path(void *dm_void, u32 path);
 void phydm_config_ofdm_tx_path(void *dm_void, u32 path)
 {
 #if (RTL8192E_SUPPORT || RTL8812A_SUPPORT)
@@ -475,6 +478,7 @@ void phydm_config_cck_rx_path(void *dm_void, enum bb_path path)
 #endif
 }
 
+void phydm_config_cck_tx_path(void *dm_void, enum bb_path path);
 void phydm_config_cck_tx_path(void *dm_void, enum bb_path path)
 {
 #if (defined(PHYDM_COMPILE_ABOVE_2SS))
@@ -489,6 +493,8 @@ void phydm_config_cck_tx_path(void *dm_void, enum bb_path path)
 #endif
 }
 
+void phydm_config_trx_path_v2(void *dm_void, char input[][16], u32 *_used,
+			      char *output, u32 *_out_len);
 void phydm_config_trx_path_v2(void *dm_void, char input[][16], u32 *_used,
 			      char *output, u32 *_out_len)
 {
@@ -542,6 +548,8 @@ void phydm_config_trx_path_v2(void *dm_void, char input[][16], u32 *_used,
 #endif
 }
 
+void phydm_config_trx_path_v1(void *dm_void, char input[][16], u32 *_used,
+			      char *output, u32 *_out_len);
 void phydm_config_trx_path_v1(void *dm_void, char input[][16], u32 *_used,
 			      char *output, u32 *_out_len)
 {
@@ -895,6 +903,7 @@ void phydm_set_ext_switch(void *dm_void, u32 ext_ant_switch)
 #endif
 }
 
+void phydm_csi_mask_enable(void *dm_void, u32 enable);
 void phydm_csi_mask_enable(void *dm_void, u32 enable)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -919,6 +928,7 @@ void phydm_csi_mask_enable(void *dm_void, u32 enable)
 	}
 }
 
+void phydm_clean_all_csi_mask(void *dm_void);
 void phydm_clean_all_csi_mask(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -957,6 +967,7 @@ void phydm_clean_all_csi_mask(void *dm_void)
 	}
 }
 
+void phydm_set_csi_mask(void *dm_void, u32 tone_idx_tmp, u8 tone_direction);
 void phydm_set_csi_mask(void *dm_void, u32 tone_idx_tmp, u8 tone_direction)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1016,6 +1027,7 @@ void phydm_set_csi_mask(void *dm_void, u32 tone_idx_tmp, u8 tone_direction)
 		  (tone_idx_tmp + tone_num_shift), target_reg, reg_tmp_value);
 }
 
+void phydm_set_nbi_reg(void *dm_void, u32 tone_idx_tmp, u32 bw);
 void phydm_set_nbi_reg(void *dm_void, u32 tone_idx_tmp, u32 bw)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1111,6 +1123,7 @@ void phydm_nbi_enable(void *dm_void, u32 enable)
 	}
 }
 
+u8 phydm_find_fc(void *dm_void, u32 channel, u32 bw, u32 second_ch, u32 *fc_in);
 u8 phydm_find_fc(void *dm_void, u32 channel, u32 bw, u32 second_ch, u32 *fc_in)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1186,6 +1199,8 @@ u8 phydm_find_fc(void *dm_void, u32 channel, u32 bw, u32 second_ch, u32 *fc_in)
 	return PHYDM_SET_SUCCESS;
 }
 
+u8 phydm_find_intf_distance(void *dm_void, u32 bw, u32 fc, u32 f_interference,
+			    u32 *tone_idx_tmp_in);
 u8 phydm_find_intf_distance(void *dm_void, u32 bw, u32 fc, u32 f_interference,
 			    u32 *tone_idx_tmp_in)
 {
@@ -2577,6 +2592,7 @@ phydm_api_trx_mode(void *dm_void, enum bb_path tx_path, enum bb_path rx_path,
 	return ret;
 }
 #else
+u8 config_phydm_read_txagc_n(void *dm_void, enum rf_path path, u8 hw_rate);
 u8 config_phydm_read_txagc_n(void *dm_void, enum rf_path path, u8 hw_rate)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_beamforming.c b/drivers/staging/rtl8812au/hal/phydm/phydm_beamforming.c
index bc4855c15..be4246612 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_beamforming.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_beamforming.c
@@ -92,6 +92,8 @@ void phydm_get_txbf_device_num(
 }
 
 struct _RT_BEAMFORM_STAINFO *
+phydm_sta_info_init(struct dm_struct *dm, u16 sta_idx, u8 *my_mac_addr);
+struct _RT_BEAMFORM_STAINFO *
 phydm_sta_info_init(struct dm_struct *dm, u16 sta_idx, u8 *my_mac_addr)
 {
 	struct _RT_BEAMFORMING_INFO *beam_info = &dm->beamforming_info;
@@ -158,6 +160,10 @@ phydm_sta_info_init(struct dm_struct *dm, u16 sta_idx, u8 *my_mac_addr)
 		  entry->cur_beamform, entry->cur_beamform_vht);
 	return entry;
 }
+void phydm_sta_info_update(
+	struct dm_struct *dm,
+	u16 sta_idx,
+	struct _RT_BEAMFORMEE_ENTRY *beamform_entry);
 void phydm_sta_info_update(
 	struct dm_struct *dm,
 	u16 sta_idx,
@@ -213,6 +219,11 @@ phydm_beamforming_get_bfer_entry_by_addr(
 }
 
 struct _RT_BEAMFORMEE_ENTRY *
+phydm_beamforming_get_entry_by_mac_id(
+	void *dm_void,
+	u8 mac_id,
+	u8 *idx);
+struct _RT_BEAMFORMEE_ENTRY *
 phydm_beamforming_get_entry_by_mac_id(
 	void *dm_void,
 	u8 mac_id,
@@ -253,6 +264,10 @@ phydm_beamforming_get_entry_beam_cap_by_mac_id(
 }
 
 struct _RT_BEAMFORMEE_ENTRY *
+phydm_beamforming_get_free_bfee_entry(
+	void *dm_void,
+	u8 *idx);
+struct _RT_BEAMFORMEE_ENTRY *
 phydm_beamforming_get_free_bfee_entry(
 	void *dm_void,
 	u8 *idx)
@@ -271,6 +286,10 @@ phydm_beamforming_get_free_bfee_entry(
 }
 
 struct _RT_BEAMFORMER_ENTRY *
+phydm_beamforming_get_free_bfer_entry(
+	void *dm_void,
+	u8 *idx);
+struct _RT_BEAMFORMER_ENTRY *
 phydm_beamforming_get_free_bfer_entry(
 	void *dm_void,
 	u8 *idx)
@@ -298,6 +317,8 @@ phydm_beamforming_get_free_bfer_entry(
  * 2015.05.25. Created by tynli.
  *
  */
+u8 phydm_beamforming_get_first_mu_bfee_entry_idx(
+	void *dm_void);
 u8 phydm_beamforming_get_first_mu_bfee_entry_idx(
 	void *dm_void)
 {
@@ -323,6 +344,14 @@ u8 phydm_beamforming_get_first_mu_bfee_entry_idx(
 
 /*@Add SU BFee and MU BFee*/
 struct _RT_BEAMFORMEE_ENTRY *
+beamforming_add_bfee_entry(
+	void *dm_void,
+	struct _RT_BEAMFORM_STAINFO *sta,
+	enum beamforming_cap beamform_cap,
+	u8 num_of_sounding_dim,
+	u8 comp_steering_num_of_bfer,
+	u8 *idx);
+struct _RT_BEAMFORMEE_ENTRY *
 beamforming_add_bfee_entry(
 	void *dm_void,
 	struct _RT_BEAMFORM_STAINFO *sta,
@@ -400,6 +429,13 @@ beamforming_add_bfee_entry(
 
 /*@Add SU BFee and MU BFer*/
 struct _RT_BEAMFORMER_ENTRY *
+beamforming_add_bfer_entry(
+	void *dm_void,
+	struct _RT_BEAMFORM_STAINFO *sta,
+	enum beamforming_cap beamform_cap,
+	u8 num_of_sounding_dim,
+	u8 *idx);
+struct _RT_BEAMFORMER_ENTRY *
 beamforming_add_bfer_entry(
 	void *dm_void,
 	struct _RT_BEAMFORM_STAINFO *sta,
@@ -496,6 +532,10 @@ beamforming_remove_entry(
 #endif
 
 /* Used for beamforming_start_v1 */
+void phydm_beamforming_ndpa_rate(
+	void *dm_void,
+	enum channel_width BW,
+	u8 rate);
 void phydm_beamforming_ndpa_rate(
 	void *dm_void,
 	enum channel_width BW,
@@ -521,6 +561,8 @@ void phydm_beamforming_ndpa_rate(
 }
 
 /* Used for beamforming_start_sw and  beamforming_start_fw */
+void phydm_beamforming_dym_ndpa_rate(
+	void *dm_void);
 void phydm_beamforming_dym_ndpa_rate(
 	void *dm_void)
 {
@@ -541,6 +583,9 @@ void phydm_beamforming_dym_ndpa_rate(
 *				 HW Timer unit (1/32000) s  32k is clock.
 *	FW Sounding : FW Timer unit 10ms
 */
+void beamforming_dym_period(
+	void *dm_void,
+	u8 status);
 void beamforming_dym_period(
 	void *dm_void,
 	u8 status)
@@ -655,6 +700,11 @@ beamforming_send_vht_ndpa_packet(
 }
 
 enum beamforming_notify_state
+phydm_beamfomring_is_sounding(
+	void *dm_void,
+	struct _RT_BEAMFORMING_INFO *beam_info,
+	u8 *idx);
+enum beamforming_notify_state
 phydm_beamfomring_is_sounding(
 	void *dm_void,
 	struct _RT_BEAMFORMING_INFO *beam_info,
@@ -707,6 +757,9 @@ phydm_beamfomring_is_sounding(
 }
 
 /* This function is unused */
+u8 phydm_beamforming_sounding_idx(
+	void *dm_void,
+	struct _RT_BEAMFORMING_INFO *beam_info);
 u8 phydm_beamforming_sounding_idx(
 	void *dm_void,
 	struct _RT_BEAMFORMING_INFO *beam_info)
@@ -734,6 +787,11 @@ u8 phydm_beamforming_sounding_idx(
 }
 
 enum sounding_mode
+phydm_beamforming_sounding_mode(
+	void *dm_void,
+	struct _RT_BEAMFORMING_INFO *beam_info,
+	u8 idx);
+enum sounding_mode
 phydm_beamforming_sounding_mode(
 	void *dm_void,
 	struct _RT_BEAMFORMING_INFO *beam_info,
@@ -775,6 +833,11 @@ phydm_beamforming_sounding_mode(
 	return mode;
 }
 
+u16 phydm_beamforming_sounding_time(
+	void *dm_void,
+	struct _RT_BEAMFORMING_INFO *beam_info,
+	enum sounding_mode mode,
+	u8 idx);
 u16 phydm_beamforming_sounding_time(
 	void *dm_void,
 	struct _RT_BEAMFORMING_INFO *beam_info,
@@ -800,6 +863,12 @@ u16 phydm_beamforming_sounding_time(
 }
 
 enum channel_width
+phydm_beamforming_sounding_bw(
+	void *dm_void,
+	struct _RT_BEAMFORMING_INFO *beam_info,
+	enum sounding_mode mode,
+	u8 idx);
+enum channel_width
 phydm_beamforming_sounding_bw(
 	void *dm_void,
 	struct _RT_BEAMFORMING_INFO *beam_info,
@@ -825,6 +894,10 @@ phydm_beamforming_sounding_bw(
 	return sounding_bw;
 }
 
+boolean
+phydm_beamforming_select_beam_entry(
+	void *dm_void,
+	struct _RT_BEAMFORMING_INFO *beam_info);
 boolean
 phydm_beamforming_select_beam_entry(
 	void *dm_void,
@@ -857,6 +930,9 @@ phydm_beamforming_select_beam_entry(
 
 /*SU BFee Entry Only*/
 boolean
+phydm_beamforming_start_period(
+	void *dm_void);
+boolean
 phydm_beamforming_start_period(
 	void *dm_void)
 {
@@ -901,6 +977,8 @@ phydm_beamforming_start_period(
 
 /* Used after beamforming_leave, and will clear the setting of the "already deleted" entry
  *SU BFee Entry Only*/
+void phydm_beamforming_end_period_sw(
+	void *dm_void);
 void phydm_beamforming_end_period_sw(
 	void *dm_void)
 {
@@ -922,6 +1000,8 @@ void phydm_beamforming_end_period_sw(
 	/*odm_write_1byte(dm, 0x15F, 0);*/
 }
 
+void phydm_beamforming_end_period_fw(
+	void *dm_void);
 void phydm_beamforming_end_period_fw(
 	void *dm_void)
 {
@@ -933,6 +1013,10 @@ void phydm_beamforming_end_period_fw(
 }
 
 /*SU BFee Entry Only*/
+void phydm_beamforming_clear_entry_sw(
+	void *dm_void,
+	boolean is_delete,
+	u8 delete_idx);
 void phydm_beamforming_clear_entry_sw(
 	void *dm_void,
 	boolean is_delete,
@@ -998,6 +1082,10 @@ void phydm_beamforming_clear_entry_sw(
 	}
 }
 
+void phydm_beamforming_clear_entry_fw(
+	void *dm_void,
+	boolean is_delete,
+	u8 delete_idx);
 void phydm_beamforming_clear_entry_fw(
 	void *dm_void,
 	boolean is_delete,
@@ -1143,6 +1231,9 @@ void phydm_beamforming_notify(
 	}
 }
 
+boolean
+beamforming_init_entry(void *dm_void, u16 sta_idx, u8 *bfer_bfee_idx,
+		       u8 *my_mac_addr);
 boolean
 beamforming_init_entry(void *dm_void, u16 sta_idx, u8 *bfer_bfee_idx,
 		       u8 *my_mac_addr)
@@ -1293,6 +1384,9 @@ beamforming_init_entry(void *dm_void, u16 sta_idx, u8 *bfer_bfee_idx,
 	return true;
 }
 
+void beamforming_deinit_entry(
+	void *dm_void,
+	u8 *RA);
 void beamforming_deinit_entry(
 	void *dm_void,
 	u8 *RA)
@@ -1336,6 +1430,13 @@ void beamforming_deinit_entry(
 	PHYDM_DBG(dm, DBG_TXBF, "%s End, idx = 0x%X\n", __func__, idx);
 }
 
+boolean
+beamforming_start_v1(
+	void *dm_void,
+	u8 *RA,
+	boolean mode,
+	enum channel_width BW,
+	u8 rate);
 boolean
 beamforming_start_v1(
 	void *dm_void,
@@ -1402,6 +1503,12 @@ beamforming_start_v1(
 	return true;
 }
 
+boolean
+beamforming_start_sw(
+	void *dm_void,
+	u8 idx,
+	u8 mode,
+	enum channel_width BW);
 boolean
 beamforming_start_sw(
 	void *dm_void,
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_cck_pd.c b/drivers/staging/rtl8812au/hal/phydm/phydm_cck_pd.c
index 8f5229abf..0be5ae0fc 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_cck_pd.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_cck_pd.c
@@ -32,6 +32,7 @@
 
 #ifdef PHYDM_SUPPORT_CCKPD
 #ifdef PHYDM_COMPILE_CCKPD_TYPE1
+void phydm_write_cck_pd_type1(void *dm_void, u8 cca_th);
 void phydm_write_cck_pd_type1(void *dm_void, u8 cca_th)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -44,6 +45,7 @@ void phydm_write_cck_pd_type1(void *dm_void, u8 cca_th)
 	cckpd_t->cur_cck_cca_thres = cca_th;
 }
 
+void phydm_set_cckpd_lv_type1(void *dm_void, enum cckpd_lv lv);
 void phydm_set_cckpd_lv_type1(void *dm_void, enum cckpd_lv lv)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -75,6 +77,7 @@ void phydm_set_cckpd_lv_type1(void *dm_void, enum cckpd_lv lv)
 	phydm_write_cck_pd_type1(dm, pd_th);
 }
 
+void phydm_cckpd_type1(void *dm_void);
 void phydm_cckpd_type1(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -952,6 +955,8 @@ void phydm_set_cckpd_val(void *dm_void, u32 *val_buf, u8 val_len)
 	}
 }
 
+boolean
+phydm_stop_cck_pd_th(void *dm_void);
 boolean
 phydm_stop_cck_pd_th(void *dm_void)
 {
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_ccx.c b/drivers/staging/rtl8812au/hal/phydm/phydm_ccx.c
index f9ea9bb99..e0f42c0be 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_ccx.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_ccx.c
@@ -328,6 +328,7 @@ void phydm_fahm_dbg(void *dm_void, char input[][16], u32 *_used, char *output,
 
 #ifdef NHM_SUPPORT
 
+void phydm_nhm_racing_release(void *dm_void);
 void phydm_nhm_racing_release(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -348,6 +349,7 @@ void phydm_nhm_racing_release(void *dm_void)
 	ccx->nhm_app = NHM_BACKGROUND;
 }
 
+u8 phydm_nhm_racing_ctrl(void *dm_void, enum phydm_nhm_level nhm_lv);
 u8 phydm_nhm_racing_ctrl(void *dm_void, enum phydm_nhm_level nhm_lv)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -397,6 +399,8 @@ void phydm_nhm_trigger(void *dm_void)
 	ccx->nhm_ongoing = true;
 }
 
+boolean
+phydm_nhm_check_rdy(void *dm_void);
 boolean
 phydm_nhm_check_rdy(void *dm_void)
 {
@@ -487,6 +491,7 @@ phydm_nhm_check_rdy(void *dm_void)
 	return is_ready;
 }
 
+void phydm_nhm_get_utility(void *dm_void);
 void phydm_nhm_get_utility(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -504,6 +509,8 @@ void phydm_nhm_get_utility(void *dm_void)
 	PHYDM_DBG(dm, DBG_ENV_MNTR, "nhm_ratio=%d\n", ccx->nhm_ratio);
 }
 
+boolean
+phydm_nhm_get_result(void *dm_void);
 boolean
 phydm_nhm_get_result(void *dm_void)
 {
@@ -629,6 +636,7 @@ phydm_nhm_get_result(void *dm_void)
 	return true;
 }
 
+void phydm_nhm_set_th_reg(void *dm_void);
 void phydm_nhm_set_th_reg(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -679,6 +687,9 @@ void phydm_nhm_set_th_reg(void *dm_void)
 		  ccx->nhm_th[1], ccx->nhm_th[0]);
 }
 
+boolean
+phydm_nhm_th_update_chk(void *dm_void, enum nhm_application nhm_app, u8 *nhm_th,
+			u32 *igi_new);
 boolean
 phydm_nhm_th_update_chk(void *dm_void, enum nhm_application nhm_app, u8 *nhm_th,
 			u32 *igi_new)
@@ -763,6 +774,10 @@ phydm_nhm_th_update_chk(void *dm_void, enum nhm_application nhm_app, u8 *nhm_th,
 	return is_update;
 }
 
+void phydm_nhm_set(void *dm_void, enum nhm_option_txon_all include_tx,
+		   enum nhm_option_cca_all include_cca,
+		   enum nhm_divider_opt_all divi_opt,
+		   enum nhm_application nhm_app, u16 period);
 void phydm_nhm_set(void *dm_void, enum nhm_option_txon_all include_tx,
 		   enum nhm_option_cca_all include_cca,
 		   enum nhm_divider_opt_all divi_opt,
@@ -854,6 +869,7 @@ void phydm_nhm_set(void *dm_void, enum nhm_option_txon_all include_tx,
 	}
 }
 
+u8 phydm_nhm_mntr_set(void *dm_void, struct nhm_para_info *nhm_para);
 u8 phydm_nhm_mntr_set(void *dm_void, struct nhm_para_info *nhm_para)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -885,6 +901,8 @@ u8 phydm_nhm_mntr_set(void *dm_void, struct nhm_para_info *nhm_para)
 
 /*@Environment Monitor*/
 boolean
+phydm_nhm_mntr_chk(void *dm_void, u16 monitor_time /*unit ms*/);
+boolean
 phydm_nhm_mntr_chk(void *dm_void, u16 monitor_time /*unit ms*/)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1067,6 +1085,7 @@ void phydm_nhm_dbg(void *dm_void, char input[][16], u32 *_used, char *output,
 
 #ifdef CLM_SUPPORT
 
+void phydm_clm_racing_release(void *dm_void);
 void phydm_clm_racing_release(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1080,6 +1099,7 @@ void phydm_clm_racing_release(void *dm_void)
 	ccx->clm_app = CLM_BACKGROUND;
 }
 
+u8 phydm_clm_racing_ctrl(void *dm_void, enum phydm_nhm_level clm_lv);
 u8 phydm_clm_racing_ctrl(void *dm_void, enum phydm_nhm_level clm_lv)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1318,6 +1338,7 @@ phydm_clm_get_result(void *dm_void)
 	return true;
 }
 
+void phydm_clm_mntr_fw(void *dm_void, u16 monitor_time /*unit ms*/);
 void phydm_clm_mntr_fw(void *dm_void, u16 monitor_time /*unit ms*/)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1378,6 +1399,8 @@ u8 phydm_clm_mntr_set(void *dm_void, struct clm_para_info *clm_para)
 	return PHYDM_SET_SUCCESS;
 }
 
+boolean
+phydm_clm_mntr_chk(void *dm_void, u16 monitor_time /*unit ms*/);
 boolean
 phydm_clm_mntr_chk(void *dm_void, u16 monitor_time /*unit ms*/)
 {
@@ -1441,6 +1464,7 @@ void phydm_set_clm_mntr_mode(void *dm_void, enum clm_monitor_mode mode)
 	}
 }
 
+void phydm_clm_init(void *dm_void);
 void phydm_clm_init(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_cfotracking.c b/drivers/staging/rtl8812au/hal/phydm/phydm_cfotracking.c
index 95d89e379..8aac6b094 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_cfotracking.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_cfotracking.c
@@ -25,6 +25,7 @@
 #include "mp_precomp.h"
 #include "phydm_precomp.h"
 
+s32 phydm_get_cfo_hz(void *dm_void, u32 val, u8 bit_num, u8 frac_num);
 s32 phydm_get_cfo_hz(void *dm_void, u32 val, u8 bit_num, u8 frac_num)
 {
 	s32 val_s = 0;
@@ -42,6 +43,7 @@ s32 phydm_get_cfo_hz(void *dm_void, u32 val, u8 bit_num, u8 frac_num)
 }
 
 #if (ODM_IC_11AC_SERIES_SUPPORT)
+void phydm_get_cfo_info_ac(void *dm_void, struct phydm_cfo_rpt *cfo);
 void phydm_get_cfo_info_ac(void *dm_void, struct phydm_cfo_rpt *cfo)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -310,6 +312,7 @@ phydm_set_crystal_cap_reg(void *dm_void, u8 crystal_cap)
 	return true;
 }
 
+void phydm_cfo_tracking_reset(void *dm_void);
 void phydm_cfo_tracking_reset(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_debug.c b/drivers/staging/rtl8812au/hal/phydm/phydm_debug.c
index 57d24e0e6..bab92632e 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_debug.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_debug.c
@@ -101,6 +101,7 @@ void phydm_bb_dbg_port_header_sel(void *dm_void, u32 header_idx)
 	}
 }
 
+void phydm_bb_dbg_port_clock_en(void *dm_void, u8 enable);
 void phydm_bb_dbg_port_clock_en(void *dm_void, u8 enable)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -400,6 +401,8 @@ void phydm_bb_hw_dbg_info_8822b(void *dm_void, u32 *_used, char *output,
 }
 #endif
 
+void phydm_bb_hw_dbg_info_ac(void *dm_void, u32 *_used, char *output,
+			     u32 *_out_len);
 void phydm_bb_hw_dbg_info_ac(void *dm_void, u32 *_used, char *output,
 			     u32 *_out_len)
 {
@@ -926,6 +929,8 @@ u8 phydm_get_l_sig_rate(void *dm_void, u8 rate_idx_l_sig)
 	return rate_idx;
 }
 
+void phydm_bb_hw_dbg_info(void *dm_void, char input[][16], u32 *_used,
+			  char *output, u32 *_out_len);
 void phydm_bb_hw_dbg_info(void *dm_void, char input[][16], u32 *_used,
 			  char *output, u32 *_out_len)
 {
@@ -1656,6 +1661,8 @@ void phydm_rx_rate_distribution(void *dm_void)
 #endif
 }
 
+void phydm_print_hist_2_buf(void *dm_void, u16 *val, u16 len, char *buf,
+			    u16 buf_size);
 void phydm_print_hist_2_buf(void *dm_void, u16 *val, u16 len, char *buf,
 			    u16 buf_size)
 {
@@ -1676,6 +1683,7 @@ void phydm_print_hist_2_buf(void *dm_void, u16 *val, u16 len, char *buf,
 	}
 }
 
+void phydm_nss_hitogram(void *dm_void, enum PDM_RATE_TYPE rate_type);
 void phydm_nss_hitogram(void *dm_void, enum PDM_RATE_TYPE rate_type)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1935,6 +1943,7 @@ void phydm_get_phy_statistic(void *dm_void)
 	phydm_reset_phystatus_statistic(dm);
 };
 
+void phydm_basic_dbg_msg_linked(void *dm_void);
 void phydm_basic_dbg_msg_linked(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -2554,6 +2563,8 @@ void phydm_fw_trace_en_h2c(void *dm_void, boolean enable,
 	odm_fill_h2c_cmd(dm, PHYDM_H2C_FW_TRACE_EN, cmd_length, h2c_parameter);
 }
 
+void phydm_get_per_path_txagc(void *dm_void, u8 path, u32 *_used, char *output,
+			      u32 *_out_len);
 void phydm_get_per_path_txagc(void *dm_void, u8 path, u32 *_used, char *output,
 			      u32 *_out_len)
 {
@@ -2628,6 +2639,7 @@ void phydm_get_per_path_txagc(void *dm_void, u8 path, u32 *_used, char *output,
 	*_out_len = out_len;
 }
 
+void phydm_get_txagc(void *dm_void, u32 *_used, char *output, u32 *_out_len);
 void phydm_get_txagc(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -2658,6 +2670,8 @@ void phydm_get_txagc(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 	*_out_len = out_len;
 }
 
+void phydm_set_txagc(void *dm_void, u32 *const val, u32 *_used,
+		     char *output, u32 *_out_len);
 void phydm_set_txagc(void *dm_void, u32 *const val, u32 *_used,
 		     char *output, u32 *_out_len)
 {
@@ -2738,6 +2752,8 @@ void phydm_set_txagc(void *dm_void, u32 *const val, u32 *_used,
 	*_out_len = out_len;
 }
 
+void phydm_shift_txagc(void *dm_void, u32 *const val, u32 *_used, char *output,
+		       u32 *_out_len);
 void phydm_shift_txagc(void *dm_void, u32 *const val, u32 *_used, char *output,
 		       u32 *_out_len)
 {
@@ -2850,6 +2866,8 @@ void phydm_shift_txagc(void *dm_void, u32 *const val, u32 *_used, char *output,
 	*_out_len = out_len;
 }
 
+void phydm_set_txagc_dbg(void *dm_void, char input[][16], u32 *_used,
+			 char *output, u32 *_out_len);
 void phydm_set_txagc_dbg(void *dm_void, char input[][16], u32 *_used,
 			 char *output, u32 *_out_len)
 {
@@ -2891,6 +2909,8 @@ void phydm_set_txagc_dbg(void *dm_void, char input[][16], u32 *_used,
 	*_out_len = out_len;
 }
 
+void phydm_debug_trace(void *dm_void, char input[][16], u32 *_used,
+		       char *output, u32 *_out_len);
 void phydm_debug_trace(void *dm_void, char input[][16], u32 *_used,
 		       char *output, u32 *_out_len)
 {
@@ -3047,6 +3067,8 @@ void phydm_debug_trace(void *dm_void, char input[][16], u32 *_used,
 	*_out_len = out_len;
 }
 
+void phydm_fw_debug_trace(void *dm_void, char input[][16], u32 *_used,
+			  char *output, u32 *_out_len);
 void phydm_fw_debug_trace(void *dm_void, char input[][16], u32 *_used,
 			  char *output, u32 *_out_len)
 {
@@ -3126,6 +3148,8 @@ void phydm_dump_bb_reg_n(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 #endif
 
 #if (ODM_IC_11AC_SERIES_SUPPORT)
+void phydm_dump_bb_reg_ac(void *dm_void, u32 *_used, char *output,
+			  u32 *_out_len);
 void phydm_dump_bb_reg_ac(void *dm_void, u32 *_used, char *output,
 			  u32 *_out_len)
 {
@@ -3247,6 +3271,7 @@ void phydm_dump_bb_reg2_jgr3(void *dm_void, u32 *_used, char *output,
 }
 #endif
 
+void phydm_dump_bb_reg(void *dm_void, u32 *_used, char *output, u32 *_out_len);
 void phydm_dump_bb_reg(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -3277,6 +3302,7 @@ void phydm_dump_bb_reg(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 	*_out_len = out_len;
 }
 
+void phydm_dump_rf_reg(void *dm_void, u32 *_used, char *output, u32 *_out_len);
 void phydm_dump_rf_reg(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -3341,6 +3367,7 @@ void phydm_dump_rf_reg(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 	*_out_len = out_len;
 }
 
+void phydm_dump_mac_reg(void *dm_void, u32 *_used, char *output, u32 *_out_len);
 void phydm_dump_mac_reg(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -3366,6 +3393,8 @@ void phydm_dump_mac_reg(void *dm_void, u32 *_used, char *output, u32 *_out_len)
 	*_out_len = out_len;
 }
 
+void phydm_dump_reg(void *dm_void, char input[][16], u32 *_used, char *output,
+		    u32 *_out_len);
 void phydm_dump_reg(void *dm_void, char input[][16], u32 *_used, char *output,
 		    u32 *_out_len)
 {
@@ -3416,6 +3445,8 @@ void phydm_dump_reg(void *dm_void, char input[][16], u32 *_used, char *output,
 	*_out_len = out_len;
 }
 
+void phydm_enable_big_jump(void *dm_void, char input[][16], u32 *_used,
+			   char *output, u32 *_out_len);
 void phydm_enable_big_jump(void *dm_void, char input[][16], u32 *_used,
 			   char *output, u32 *_out_len)
 {
@@ -3453,6 +3484,8 @@ void phydm_enable_big_jump(void *dm_void, char input[][16], u32 *_used,
 #endif
 }
 
+void phydm_show_rx_rate(void *dm_void, char input[][16], u32 *_used,
+			char *output, u32 *_out_len);
 void phydm_show_rx_rate(void *dm_void, char input[][16], u32 *_used,
 			char *output, u32 *_out_len)
 {
@@ -3541,6 +3574,8 @@ void phydm_show_rx_rate(void *dm_void, char input[][16], u32 *_used,
 #endif
 }
 
+void phydm_per_tone_evm(void *dm_void, char input[][16], u32 *_used,
+			char *output, u32 *_out_len);
 void phydm_per_tone_evm(void *dm_void, char input[][16], u32 *_used,
 			char *output, u32 *_out_len)
 {
@@ -3754,6 +3789,8 @@ void phydm_per_tone_evm(void *dm_void, char input[][16], u32 *_used,
 	*_out_len = out_len;
 }
 
+void phydm_bw_ch_adjust(void *dm_void, char input[][16],
+			u32 *_used, char *output, u32 *_out_len);
 void phydm_bw_ch_adjust(void *dm_void, char input[][16],
 			u32 *_used, char *output, u32 *_out_len)
 {
@@ -3806,6 +3843,8 @@ void phydm_bw_ch_adjust(void *dm_void, char input[][16],
 	*_out_len = out_len;
 }
 
+void phydm_ext_rf_element_ctrl(void *dm_void, char input[][16], u32 *_used,
+			       char *output, u32 *_out_len);
 void phydm_ext_rf_element_ctrl(void *dm_void, char input[][16], u32 *_used,
 			       char *output, u32 *_out_len)
 {
@@ -3828,6 +3867,8 @@ void phydm_ext_rf_element_ctrl(void *dm_void, char input[][16], u32 *_used,
 	}
 }
 
+void phydm_print_dbgport(void *dm_void, char input[][16], u32 *_used,
+			 char *output, u32 *_out_len);
 void phydm_print_dbgport(void *dm_void, char input[][16], u32 *_used,
 			 char *output, u32 *_out_len)
 {
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_dig.c b/drivers/staging/rtl8812au/hal/phydm/phydm_dig.c
index eea6dcee4..b26e85515 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_dig.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_dig.c
@@ -31,6 +31,7 @@
 #include "phydm_precomp.h"
 
 #ifdef CFG_DIG_DAMPING_CHK
+void phydm_dig_recorder_reset(void *dm_void);
 void phydm_dig_recorder_reset(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -43,6 +44,8 @@ void phydm_dig_recorder_reset(void *dm_void)
 		       sizeof(struct phydm_dig_recorder_strcut));
 }
 
+void phydm_dig_recorder(void *dm_void, boolean first_connect, u8 igi_curr,
+			u32 fa_cnt);
 void phydm_dig_recorder(void *dm_void, boolean first_connect, u8 igi_curr,
 			u32 fa_cnt)
 {
@@ -95,6 +98,7 @@ void phydm_dig_recorder(void *dm_void, boolean first_connect, u8 igi_curr,
 		  dig_rc->igi_bitmap);
 }
 
+void phydm_dig_damping_chk(void *dm_void);
 void phydm_dig_damping_chk(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -195,6 +199,8 @@ void phydm_dig_damping_chk(void *dm_void)
 }
 #endif
 
+boolean
+phydm_dig_go_up_check(void *dm_void);
 boolean
 phydm_dig_go_up_check(void *dm_void)
 {
@@ -271,6 +277,7 @@ phydm_dig_go_up_check(void *dm_void)
 	return ret;
 }
 
+void phydm_fa_threshold_check(void *dm_void, boolean is_dfs_band);
 void phydm_fa_threshold_check(void *dm_void, boolean is_dfs_band)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -310,6 +317,7 @@ void phydm_fa_threshold_check(void *dm_void, boolean is_dfs_band)
 		  dig_t->fa_th[1], dig_t->fa_th[2]);
 }
 
+void phydm_set_big_jump_step(void *dm_void, u8 curr_igi);
 void phydm_set_big_jump_step(void *dm_void, u8 curr_igi)
 {
 #if (RTL8822B_SUPPORT || RTL8197F_SUPPORT || RTL8192F_SUPPORT)
@@ -498,6 +506,7 @@ void phydm_fa_cnt_statistics_jgr3(void *dm_void)
 
 #endif
 
+void phydm_write_dig_reg_c50(void *dm_void, u8 igi);
 void phydm_write_dig_reg_c50(void *dm_void, u8 igi)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -598,6 +607,7 @@ void odm_write_dig(void *dm_void, u8 new_igi)
 	PHYDM_DBG(dm, DBG_DIG, "New_igi=((0x%x))\n\n", new_igi);
 }
 
+u8 phydm_get_igi_reg_val(void *dm_void, enum bb_path path);
 u8 phydm_get_igi_reg_val(void *dm_void, enum bb_path path)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -689,6 +699,8 @@ void odm_pause_dig(void *dm_void, enum phydm_pause_type type,
 	PHYDM_DBG(dm, DBG_DIG, "pause_result=%d\n", rpt);
 }
 
+boolean
+phydm_dig_abort(void *dm_void);
 boolean
 phydm_dig_abort(void *dm_void)
 {
@@ -787,6 +799,7 @@ void phydm_dig_init(void *dm_void)
 #endif
 }
 
+void phydm_dig_abs_boundary_decision(struct dm_struct *dm, boolean is_dfs_band);
 void phydm_dig_abs_boundary_decision(struct dm_struct *dm, boolean is_dfs_band)
 {
 	struct phydm_dig_struct *dig_t = &dm->dm_dig_table;
@@ -839,6 +852,7 @@ void phydm_dig_abs_boundary_decision(struct dm_struct *dm, boolean is_dfs_band)
 		  dig_t->dm_dig_max, dig_t->dm_dig_min, dig_t->dig_max_of_min);
 }
 
+void phydm_dig_dym_boundary_decision(struct dm_struct *dm);
 void phydm_dig_dym_boundary_decision(struct dm_struct *dm)
 {
 	struct phydm_dig_struct *dig_t = &dm->dm_dig_table;
@@ -918,6 +932,7 @@ void phydm_dig_dym_boundary_decision(struct dm_struct *dm)
 		  dig_t->rx_gain_range_max, dig_t->rx_gain_range_min);
 }
 
+void phydm_dig_abnormal_case(struct dm_struct *dm);
 void phydm_dig_abnormal_case(struct dm_struct *dm)
 {
 	struct phydm_dig_struct *dig_t = &dm->dm_dig_table;
@@ -930,6 +945,7 @@ void phydm_dig_abnormal_case(struct dm_struct *dm)
 		  dig_t->rx_gain_range_max, dig_t->rx_gain_range_min);
 }
 
+u8 phydm_new_igi_by_fa(struct dm_struct *dm, u8 igi, u32 fa_cnt, u8 *step_size);
 u8 phydm_new_igi_by_fa(struct dm_struct *dm, u8 igi, u32 fa_cnt, u8 *step_size)
 {
 	boolean dig_go_up_check = true;
@@ -949,6 +965,8 @@ u8 phydm_new_igi_by_fa(struct dm_struct *dm, u8 igi, u32 fa_cnt, u8 *step_size)
 	return igi;
 }
 
+u8 phydm_get_new_igi(struct dm_struct *dm, u8 igi, u32 fa_cnt,
+		     boolean is_dfs_band);
 u8 phydm_get_new_igi(struct dm_struct *dm, u8 igi, u32 fa_cnt,
 		     boolean is_dfs_band)
 {
@@ -1045,6 +1063,7 @@ u8 phydm_get_new_igi(struct dm_struct *dm, u8 igi, u32 fa_cnt,
 	return igi;
 }
 
+boolean phydm_dig_dfs_mode_en(void *dm_void);
 boolean phydm_dig_dfs_mode_en(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1203,6 +1222,7 @@ void phydm_dig_by_rssi_lps(void *dm_void)
  * 3 FASLE ALARM CHECK
  * 3============================================================
  */
+void phydm_false_alarm_counter_reg_reset(void *dm_void);
 void phydm_false_alarm_counter_reg_reset(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1299,6 +1319,7 @@ void phydm_false_alarm_counter_reg_reset(void *dm_void)
 #endif /* @#if (ODM_IC_11AC_SERIES_SUPPORT) */
 }
 
+void phydm_false_alarm_counter_reg_hold(void *dm_void);
 void phydm_false_alarm_counter_reg_hold(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1418,6 +1439,7 @@ void phydm_fa_cnt_statistics_n(void *dm_void)
 #endif
 
 #if (ODM_IC_11AC_SERIES_SUPPORT)
+void phydm_fa_cnt_statistics_ac(void *dm_void);
 void phydm_fa_cnt_statistics_ac(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1510,6 +1532,7 @@ void phydm_fa_cnt_statistics_ac(void *dm_void)
 }
 #endif
 
+void phydm_get_dbg_port_info(void *dm_void);
 void phydm_get_dbg_port_info(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_interface.c b/drivers/staging/rtl8812au/hal/phydm/phydm_interface.c
index fe0f5c220..ef2cac6d0 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_interface.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_interface.c
@@ -749,6 +749,7 @@ void odm_release_timer(struct dm_struct *dm, struct phydm_timer_list *timer)
 #endif
 }
 
+u8 phydm_trans_h2c_id(struct dm_struct *dm, u8 phydm_h2c_id);
 u8 phydm_trans_h2c_id(struct dm_struct *dm, u8 phydm_h2c_id)
 {
 	u8 platform_h2c_id = phydm_h2c_id;
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_noisemonitor.c b/drivers/staging/rtl8812au/hal/phydm/phydm_noisemonitor.c
index 77fe94e3f..6e76266d9 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_noisemonitor.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_noisemonitor.c
@@ -39,6 +39,7 @@
  *
  *************************************************/
 
+void phydm_set_noise_data_sum(struct noise_level *noise_data, u8 max_rf_path);
 void phydm_set_noise_data_sum(struct noise_level *noise_data, u8 max_rf_path)
 {
 	u8 i = 0;
@@ -152,6 +153,8 @@ s16 odm_inband_noise_monitor_n(struct dm_struct *dm, u8 is_pause_dig, u8 igi,
 #endif
 
 #if (ODM_IC_11AC_SERIES_SUPPORT)
+s16 phydm_idle_noise_measure_ac(struct dm_struct *dm, u8 pause_dig,
+				u8 igi, u32 max_time);
 s16 phydm_idle_noise_measure_ac(struct dm_struct *dm, u8 pause_dig,
 				u8 igi, u32 max_time)
 {
@@ -251,6 +254,8 @@ s16 phydm_idle_noise_measure_ac(struct dm_struct *dm, u8 pause_dig,
 	return dm->noise_level.noise_all;
 }
 
+s16 odm_inband_noise_monitor_ac(struct dm_struct *dm, u8 pause_dig, u8 igi,
+				u32 max_time);
 s16 odm_inband_noise_monitor_ac(struct dm_struct *dm, u8 pause_dig, u8 igi,
 				u32 max_time)
 {
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_phystatus.c b/drivers/staging/rtl8812au/hal/phydm/phydm_phystatus.c
index 060390b3c..627eb5074 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_phystatus.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_phystatus.c
@@ -68,6 +68,10 @@ u8 phydm_get_gid(struct dm_struct *dm, u8 *phy_status_inf)
 }
 #endif
 
+void phydm_rx_statistic_cal(struct dm_struct *dm,
+			    struct phydm_phyinfo_struct *phy_info,
+			    u8 *phy_status_inf,
+			    struct phydm_perpkt_info_struct *pktinfo);
 void phydm_rx_statistic_cal(struct dm_struct *dm,
 			    struct phydm_phyinfo_struct *phy_info,
 			    u8 *phy_status_inf,
@@ -186,6 +190,9 @@ void phydm_reset_phystatus_statistic(struct dm_struct *dm)
 		       sizeof(struct phydm_phystatus_statistic));
 }
 
+void phydm_avg_phystatus_index(void *dm_void,
+			       struct phydm_phyinfo_struct *phy_info,
+			       struct phydm_perpkt_info_struct *pktinfo);
 void phydm_avg_phystatus_index(void *dm_void,
 			       struct phydm_phyinfo_struct *phy_info,
 			       struct phydm_perpkt_info_struct *pktinfo)
@@ -326,6 +333,7 @@ void phydm_avg_phystatus_index(void *dm_void,
 	}
 }
 
+void phydm_avg_phystatus_init(void *dm_void);
 void phydm_avg_phystatus_init(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -340,6 +348,9 @@ void phydm_avg_phystatus_init(void *dm_void)
 	odm_move_memory(dm, dbg_i->evm_hist_th, evm_hist_th, size);
 }
 
+u8 phydm_get_signal_quality(struct phydm_phyinfo_struct *phy_info,
+			    struct dm_struct *dm,
+			    struct phy_status_rpt_8192cd *phy_sts);
 u8 phydm_get_signal_quality(struct phydm_phyinfo_struct *phy_info,
 			    struct dm_struct *dm,
 			    struct phy_status_rpt_8192cd *phy_sts)
@@ -363,6 +374,7 @@ u8 phydm_get_signal_quality(struct phydm_phyinfo_struct *phy_info,
 	return result;
 }
 
+u8 phydm_pwr_2_percent(s8 ant_power);
 u8 phydm_pwr_2_percent(s8 ant_power)
 {
 	if ((ant_power <= -100) || ant_power >= 20)
@@ -750,6 +762,7 @@ phydm_cfo(s8 value)
 	return ret_val;
 }
 
+s8 phydm_cck_rssi_convert(struct dm_struct *dm, u16 lna_idx, u8 vga_idx);
 s8 phydm_cck_rssi_convert(struct dm_struct *dm, u16 lna_idx, u8 vga_idx)
 {
 	/*@phydm_get_cck_rssi_table_from_reg*/
@@ -791,6 +804,7 @@ void phydm_get_cck_rssi_table_from_reg(struct dm_struct *dm)
 		  dm->cck_lna_gain_table[6], dm->cck_lna_gain_table[7]);
 }
 
+s8 phydm_get_cck_rssi(void *dm_void, u8 lna_idx, u8 vga_idx);
 s8 phydm_get_cck_rssi(void *dm_void, u8 lna_idx, u8 vga_idx)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1071,6 +1085,11 @@ void phydm_phy_sts_n_parsing(struct dm_struct *dm,
 #endif
 
 #if ODM_IC_11AC_SERIES_SUPPORT
+void phydm_rx_physts_bw_parsing(struct phydm_phyinfo_struct *phy_info,
+				struct phydm_perpkt_info_struct *
+				pktinfo,
+				struct phy_status_rpt_8812 *
+				phy_sts);
 void phydm_rx_physts_bw_parsing(struct phydm_phyinfo_struct *phy_info,
 				struct phydm_perpkt_info_struct *
 				pktinfo,
@@ -1104,6 +1123,8 @@ void phydm_rx_physts_bw_parsing(struct phydm_phyinfo_struct *phy_info,
 	}
 }
 
+void phydm_get_sq(struct dm_struct *dm, struct phydm_phyinfo_struct *phy_info,
+		  u8 is_cck_rate);
 void phydm_get_sq(struct dm_struct *dm, struct phydm_phyinfo_struct *phy_info,
 		  u8 is_cck_rate)
 {
@@ -1144,6 +1165,10 @@ void phydm_get_sq(struct dm_struct *dm, struct phydm_phyinfo_struct *phy_info,
 	phy_info->signal_quality = sq;
 }
 
+void phydm_rx_physts_1st_type(struct dm_struct *dm,
+			      struct phydm_phyinfo_struct *phy_info,
+			      u8 *phy_status_inf,
+			      struct phydm_perpkt_info_struct *pktinfo);
 void phydm_rx_physts_1st_type(struct dm_struct *dm,
 			      struct phydm_phyinfo_struct *phy_info,
 			      u8 *phy_status_inf,
@@ -1312,6 +1337,7 @@ void phydm_reset_rssi_for_dm(struct dm_struct *dm, u8 station_id)
 
 #if (ODM_IC_11N_SERIES_SUPPORT || ODM_IC_11AC_SERIES_SUPPORT)
 
+s32 phydm_get_rssi_8814_ofdm(struct dm_struct *dm, u8 *rssi_in);
 s32 phydm_get_rssi_8814_ofdm(struct dm_struct *dm, u8 *rssi_in)
 {
 	s32 rssi_avg;
@@ -1358,6 +1384,9 @@ s32 phydm_get_rssi_8814_ofdm(struct dm_struct *dm, u8 *rssi_in)
 	return rssi_avg;
 }
 
+void phydm_process_rssi_for_dm(struct dm_struct *dm,
+			       struct phydm_phyinfo_struct *phy_info,
+			       struct phydm_perpkt_info_struct *pktinfo);
 void phydm_process_rssi_for_dm(struct dm_struct *dm,
 			       struct phydm_phyinfo_struct *phy_info,
 			       struct phydm_perpkt_info_struct *pktinfo)
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_rainfo.c b/drivers/staging/rtl8812au/hal/phydm/phydm_rainfo.c
index 077585dfc..2c24b9be9 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_rainfo.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_rainfo.c
@@ -51,6 +51,7 @@ boolean phydm_is_cck_rate(void *dm_void, u8 rate)
 	return ((rate & 0x7f) <= ODM_RATE11M) ? true : false;
 }
 
+u8 phydm_rate_2_rate_digit(void *dm_void, u8 rate);
 u8 phydm_rate_2_rate_digit(void *dm_void, u8 rate)
 {
 	u8 legacy_table[12] = {1, 2, 5, 11, 6, 9, 12, 18, 24, 36, 48, 54};
@@ -151,6 +152,7 @@ void phydm_h2C_debug(void *dm_void, char input[][16], u32 *_used,
 	*_out_len = out_len;
 }
 
+void phydm_fw_fix_rate(void *dm_void, u8 en, u8 macid, u8 bw, u8 rate);
 void phydm_fw_fix_rate(void *dm_void, u8 en, u8 macid, u8 bw, u8 rate)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -661,6 +663,7 @@ void phydm_update_hal_ra_mask(
 
 #endif
 
+void phydm_rate_adaptive_mask_init(void *dm_void);
 void phydm_rate_adaptive_mask_init(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -812,6 +815,7 @@ void phydm_show_sta_info(void *dm_void, char input[][16], u32 *_used,
 	*_out_len = out_len;
 }
 
+u8 phydm_get_tx_stream_num(void *dm_void, enum rf_type type);
 u8 phydm_get_tx_stream_num(void *dm_void, enum rf_type type)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -831,6 +835,7 @@ u8 phydm_get_tx_stream_num(void *dm_void, enum rf_type type)
 	return tx_num;
 }
 
+u64 phydm_get_bb_mod_ra_mask(void *dm_void, u8 sta_idx);
 u64 phydm_get_bb_mod_ra_mask(void *dm_void, u8 sta_idx)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1005,6 +1010,7 @@ u8 phydm_get_rate_from_rssi_lv(void *dm_void, u8 sta_idx)
 	return rate_idx;
 }
 
+u8 phydm_get_rate_id(void *dm_void, u8 sta_idx);
 u8 phydm_get_rate_id(void *dm_void, u8 sta_idx)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -1109,6 +1115,8 @@ u8 phydm_get_rate_id(void *dm_void, u8 sta_idx)
 	return rate_id_idx;
 }
 
+void phydm_ra_h2c(void *dm_void, u8 sta_idx, u8 dis_ra, u8 dis_pt,
+		  u8 no_update_bw, u8 init_ra_lv, u64 ra_mask);
 void phydm_ra_h2c(void *dm_void, u8 sta_idx, u8 dis_ra, u8 dis_pt,
 		  u8 no_update_bw, u8 init_ra_lv, u64 ra_mask)
 {
@@ -1379,6 +1387,7 @@ u8 phydm_vht_en_mapping(void *dm_void, u32 wireless_mode)
 	return vht_en_out;
 }
 
+u8 phydm_rftype2rateid_2g_n20(void *dm_void, u8 rf_type);
 u8 phydm_rftype2rateid_2g_n20(void *dm_void, u8 rf_type)
 {
 	u8 rate_id_idx = 0;
@@ -1394,6 +1403,7 @@ u8 phydm_rftype2rateid_2g_n20(void *dm_void, u8 rf_type)
 	return rate_id_idx;
 }
 
+u8 phydm_rftype2rateid_2g_n40(void *dm_void, u8 rf_type);
 u8 phydm_rftype2rateid_2g_n40(void *dm_void, u8 rf_type)
 {
 	u8 rate_id_idx = 0;
@@ -1409,6 +1419,7 @@ u8 phydm_rftype2rateid_2g_n40(void *dm_void, u8 rf_type)
 	return rate_id_idx;
 }
 
+u8 phydm_rftype2rateid_5g_n(void *dm_void, u8 rf_type);
 u8 phydm_rftype2rateid_5g_n(void *dm_void, u8 rf_type)
 {
 	u8 rate_id_idx = 0;
@@ -1424,6 +1435,7 @@ u8 phydm_rftype2rateid_5g_n(void *dm_void, u8 rf_type)
 	return rate_id_idx;
 }
 
+u8 phydm_rftype2rateid_ac80(void *dm_void, u8 rf_type);
 u8 phydm_rftype2rateid_ac80(void *dm_void, u8 rf_type)
 {
 	u8 rate_id_idx = 0;
@@ -1439,6 +1451,7 @@ u8 phydm_rftype2rateid_ac80(void *dm_void, u8 rf_type)
 	return rate_id_idx;
 }
 
+u8 phydm_rftype2rateid_ac40(void *dm_void, u8 rf_type);
 u8 phydm_rftype2rateid_ac40(void *dm_void, u8 rf_type)
 {
 	u8 rate_id_idx = 0;
@@ -1566,6 +1579,7 @@ u8 phydm_rate_order_compute(void *dm_void, u8 rate_idx)
 }
 
 #if (DM_ODM_SUPPORT_TYPE == ODM_CE)
+u8 phydm_rate2ss(void *dm_void, u8 rate_idx);
 u8 phydm_rate2ss(void *dm_void, u8 rate_idx)
 {
 	u8 ret = 0xff;
@@ -1591,6 +1605,7 @@ u8 phydm_rate2ss(void *dm_void, u8 rate_idx)
 	return ret;
 }
 
+u8 phydm_rate2plcp(void *dm_void, u8 rate_idx);
 u8 phydm_rate2plcp(void *dm_void, u8 rate_idx)
 {
 	u8 rate2ss = 0;
@@ -1635,6 +1650,7 @@ u8 phydm_get_plcp(void *dm_void, u16 macid)
 }
 #endif
 
+void phydm_ra_common_info_update(void *dm_void);
 void phydm_ra_common_info_update(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/phydm_rssi_monitor.c b/drivers/staging/rtl8812au/hal/phydm/phydm_rssi_monitor.c
index 0d5e41766..8936cc31e 100644
--- a/drivers/staging/rtl8812au/hal/phydm/phydm_rssi_monitor.c
+++ b/drivers/staging/rtl8812au/hal/phydm/phydm_rssi_monitor.c
@@ -32,6 +32,7 @@
 
 #ifdef PHYDM_SUPPORT_RSSI_MONITOR
 
+void phydm_rssi_monitor_h2c(void *dm_void, u8 macid);
 void phydm_rssi_monitor_h2c(void *dm_void, u8 macid)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -95,6 +96,7 @@ void phydm_rssi_monitor_h2c(void *dm_void, u8 macid)
 	}
 }
 
+void phydm_calculate_rssi_min_max(void *dm_void);
 void phydm_calculate_rssi_min_max(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
diff --git a/drivers/staging/rtl8812au/hal/phydm/rtl8821a/phydm_rtl8821a.c b/drivers/staging/rtl8812au/hal/phydm/rtl8821a/phydm_rtl8821a.c
index 5de0754da..ba3432e60 100644
--- a/drivers/staging/rtl8812au/hal/phydm/rtl8821a/phydm_rtl8821a.c
+++ b/drivers/staging/rtl8812au/hal/phydm/rtl8821a/phydm_rtl8821a.c
@@ -86,6 +86,10 @@ phydm_set_ext_band_switch_8821A(
 }
 
 
+void
+odm_dynamic_try_state_agg_8821a(
+	struct dm_struct		*dm
+);
 void
 odm_dynamic_try_state_agg_8821a(
 	struct dm_struct		*dm
@@ -99,6 +103,10 @@ odm_dynamic_try_state_agg_8821a(
 	}
 }
 
+void
+odm_dynamic_packet_detection_th_8821a(
+	struct dm_struct		*dm
+);
 void
 odm_dynamic_packet_detection_th_8821a(
 	struct dm_struct		*dm
diff --git a/drivers/staging/rtl8812au/hal/phydm/txbf/halcomtxbf.c b/drivers/staging/rtl8812au/hal/phydm/txbf/halcomtxbf.c
index ae45a5b1a..4329dcaee 100644
--- a/drivers/staging/rtl8812au/hal/phydm/txbf/halcomtxbf.c
+++ b/drivers/staging/rtl8812au/hal/phydm/txbf/halcomtxbf.c
@@ -47,6 +47,8 @@ void hal_com_txbf_config_gtab(
 		hal_txbf_8822b_config_gtab(dm);
 }
 
+void phydm_beamform_set_sounding_enter(
+	void *dm_void);
 void phydm_beamform_set_sounding_enter(
 	void *dm_void)
 {
@@ -61,6 +63,8 @@ void phydm_beamform_set_sounding_enter(
 #endif
 }
 
+void phydm_beamform_set_sounding_leave(
+	void *dm_void);
 void phydm_beamform_set_sounding_leave(
 	void *dm_void)
 {
@@ -75,6 +79,8 @@ void phydm_beamform_set_sounding_leave(
 #endif
 }
 
+void phydm_beamform_set_sounding_rate(
+	void *dm_void);
 void phydm_beamform_set_sounding_rate(
 	void *dm_void)
 {
@@ -89,6 +95,8 @@ void phydm_beamform_set_sounding_rate(
 #endif
 }
 
+void phydm_beamform_set_sounding_status(
+	void *dm_void);
 void phydm_beamform_set_sounding_status(
 	void *dm_void)
 {
@@ -103,6 +111,8 @@ void phydm_beamform_set_sounding_status(
 #endif
 }
 
+void phydm_beamform_set_sounding_fw_ndpa(
+	void *dm_void);
 void phydm_beamform_set_sounding_fw_ndpa(
 	void *dm_void)
 {
@@ -119,6 +129,8 @@ void phydm_beamform_set_sounding_fw_ndpa(
 #endif
 }
 
+void phydm_beamform_set_sounding_clk(
+	void *dm_void);
 void phydm_beamform_set_sounding_clk(
 	void *dm_void)
 {
@@ -135,6 +147,8 @@ void phydm_beamform_set_sounding_clk(
 #endif
 }
 
+void phydm_beamform_set_reset_tx_path(
+	void *dm_void);
 void phydm_beamform_set_reset_tx_path(
 	void *dm_void)
 {
@@ -150,6 +164,8 @@ void phydm_beamform_set_reset_tx_path(
 #endif
 }
 
+void phydm_beamform_set_get_tx_rate(
+	void *dm_void);
 void phydm_beamform_set_get_tx_rate(
 	void *dm_void)
 {
diff --git a/drivers/staging/rtl8812au/hal/phydm/txbf/haltxbf8814a.c b/drivers/staging/rtl8812au/hal/phydm/txbf/haltxbf8814a.c
index 7ad6ca909..328a4b5d2 100644
--- a/drivers/staging/rtl8812au/hal/phydm/txbf/haltxbf8814a.c
+++ b/drivers/staging/rtl8812au/hal/phydm/txbf/haltxbf8814a.c
@@ -233,6 +233,7 @@ u8 hal_txbf_8814a_get_ntx(void *dm_void)
 	return ntx;
 }
 
+u8 hal_txbf_8814a_get_nrx(void *dm_void);
 u8 hal_txbf_8814a_get_nrx(void *dm_void)
 {
 	struct dm_struct *dm = (struct dm_struct *)dm_void;
@@ -259,6 +260,9 @@ u8 hal_txbf_8814a_get_nrx(void *dm_void)
 	return nrx;
 }
 
+void hal_txbf_8814a_rf_mode(void *dm_void,
+			    struct _RT_BEAMFORMING_INFO *beamforming_info,
+			    u8 idx);
 void hal_txbf_8814a_rf_mode(void *dm_void,
 			    struct _RT_BEAMFORMING_INFO *beamforming_info,
 			    u8 idx)
diff --git a/drivers/staging/rtl8812au/hal/phydm/txbf/haltxbfjaguar.c b/drivers/staging/rtl8812au/hal/phydm/txbf/haltxbfjaguar.c
index 18a47d4a9..c42fa53a6 100644
--- a/drivers/staging/rtl8812au/hal/phydm/txbf/haltxbfjaguar.c
+++ b/drivers/staging/rtl8812au/hal/phydm/txbf/haltxbfjaguar.c
@@ -33,6 +33,9 @@ void hal_txbf_8812a_set_ndpa_rate(
 	odm_write_1byte(dm, REG_NDPA_OPT_CTRL_8812A, (rate << 2 | BW));
 }
 
+void hal_txbf_jaguar_rf_mode(
+	void *dm_void,
+	struct _RT_BEAMFORMING_INFO *beam_info);
 void hal_txbf_jaguar_rf_mode(
 	void *dm_void,
 	struct _RT_BEAMFORMING_INFO *beam_info)
@@ -76,6 +79,9 @@ void hal_txbf_jaguar_rf_mode(
 		odm_set_bb_reg(dm, R_0x80c, MASKBYTE1, 0x11);
 }
 
+void hal_txbf_jaguar_download_ndpa(
+	void *dm_void,
+	u8 idx);
 void hal_txbf_jaguar_download_ndpa(
 	void *dm_void,
 	u8 idx)
@@ -165,6 +171,8 @@ void hal_txbf_jaguar_download_ndpa(
 #endif
 }
 
+void hal_txbf_jaguar_fw_txbf_cmd(
+	void *dm_void);
 void hal_txbf_jaguar_fw_txbf_cmd(
 	void *dm_void)
 {
diff --git a/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_cmd.c b/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_cmd.c
index ecbb397d5..75a0594ef 100644
--- a/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_cmd.c
+++ b/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_cmd.c
@@ -158,6 +158,11 @@ u8 rtl8812_set_rssi_cmd(_adapter *padapter, u8 *param)
 	return res;
 }
 
+u8	Get_VHT_ENI(
+	u32		IOTAction,
+	u32		WirelessMode,
+	u32		ratr_bitmap
+);
 u8	Get_VHT_ENI(
 	u32		IOTAction,
 	u32		WirelessMode,
@@ -178,6 +183,13 @@ u8	Get_VHT_ENI(
 	return Ret << 4;
 }
 
+BOOLEAN
+Get_RA_ShortGI_8812(
+	PADAPTER			Adapter,
+	struct sta_info		*psta,
+	u8					shortGIrate,
+	u32					ratr_bitmap
+);
 BOOLEAN
 Get_RA_ShortGI_8812(
 	PADAPTER			Adapter,
@@ -449,6 +461,7 @@ void rtl8812_set_p2p_ps_offload_cmd(_adapter *padapter, u8 p2p_ps_state)
 }
 #endif /* CONFIG_P2P */
 
+void rtl8812_download_rsvd_page(PADAPTER padapter, u8 mstatus);
 void rtl8812_download_rsvd_page(PADAPTER padapter, u8 mstatus)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
diff --git a/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_hal_init.c b/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_hal_init.c
index 4a21818b7..5e26efadb 100644
--- a/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_hal_init.c
+++ b/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_hal_init.c
@@ -685,6 +685,11 @@ void InitializeFirmwareVars8812(PADAPTER padapter)
  * Porting from 8723B. 2013.04.01
  *   */
 VOID
+SetFwBTFwPatchCmd_8821(
+	IN PADAPTER Adapter,
+	IN u2Byte		FwSize
+);
+VOID
 SetFwBTFwPatchCmd_8821(
 	IN PADAPTER Adapter,
 	IN u2Byte		FwSize
@@ -705,6 +710,7 @@ SetFwBTFwPatchCmd_8821(
 }
 
 #ifdef CONFIG_MP_INCLUDED
+int ReservedPage_Compare(PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware, u32 BTPatchSize);
 int ReservedPage_Compare(PADAPTER Adapter, PRT_MP_FIRMWARE pFirmware, u32 BTPatchSize)
 {
 	u8 temp, ret, lastBTsz;
@@ -1119,6 +1125,12 @@ Hal_ReadAntennaDiversity8812A(
 #endif
 }
 
+VOID
+hal_ReadPAType_8812A(
+	IN	PADAPTER	Adapter,
+	IN	u8			*PROMContent,
+	IN	BOOLEAN		AutoloadFail
+);
 VOID
 hal_ReadPAType_8812A(
 	IN	PADAPTER	Adapter,
@@ -1976,6 +1988,13 @@ rtl8812_ReadEFuse(
 
 /* Do not support BT */
 VOID
+Hal_EFUSEGetEfuseDefinition8812A(
+	IN		PADAPTER	pAdapter,
+	IN		u1Byte		efuseType,
+	IN		u1Byte		type,
+	OUT		PVOID		pOut
+);
+VOID
 Hal_EFUSEGetEfuseDefinition8812A(
 	IN		PADAPTER	pAdapter,
 	IN		u1Byte		efuseType,
@@ -2057,6 +2076,13 @@ Hal_EFUSEGetEfuseDefinition8812A(
 	}
 }
 VOID
+Hal_EFUSEGetEfuseDefinition_Pseudo8812A(
+	IN		PADAPTER	pAdapter,
+	IN		u8			efuseType,
+	IN		u8			type,
+	OUT		PVOID		pOut
+);
+VOID
 Hal_EFUSEGetEfuseDefinition_Pseudo8812A(
 	IN		PADAPTER	pAdapter,
 	IN		u8			efuseType,
@@ -2486,6 +2512,14 @@ rtl8812_Efuse_PgPacketRead(IN	PADAPTER	pAdapter,
 }
 
 
+BOOLEAN
+hal_EfuseFixHeaderProcess(
+	IN		PADAPTER			pAdapter,
+	IN		u8				efuseType,
+	IN		PPGPKT_STRUCT		pFixPkt,
+	IN		u16				*pAddr,
+	IN		BOOLEAN				bPseudoTest
+);
 BOOLEAN
 hal_EfuseFixHeaderProcess(
 	IN		PADAPTER			pAdapter,
@@ -2687,6 +2721,11 @@ hal_EfusePgPacketWriteData(
 	return _TRUE;
 }
 
+BOOLEAN efuse_PgPacketCheck(
+	PADAPTER	pAdapter,
+	u8		efuseType,
+	BOOLEAN		bPseudoTest
+);
 BOOLEAN efuse_PgPacketCheck(
 	PADAPTER	pAdapter,
 	u8		efuseType,
@@ -2704,6 +2743,13 @@ BOOLEAN efuse_PgPacketCheck(
 }
 
 
+VOID
+efuse_PgPacketConstruct(
+	IN	    u8			offset,
+	IN	    u8			word_en,
+	IN	    u8			*pData,
+	IN OUT	PPGPKT_STRUCT	pTargetPkt
+);
 VOID
 efuse_PgPacketConstruct(
 	IN	    u8			offset,
@@ -2721,6 +2767,11 @@ efuse_PgPacketConstruct(
 	RTW_INFO("efuse_PgPacketConstruct(), targetPkt, offset=%d, word_en=0x%x, word_cnts=%d\n", pTargetPkt->offset, pTargetPkt->word_en, pTargetPkt->word_cnts);
 }
 
+u2Byte
+Hal_EfusePgPacketExceptionHandle_8812A(
+		PADAPTER	pAdapter,
+		u2Byte		ErrOffset
+		);
 u2Byte
 Hal_EfusePgPacketExceptionHandle_8812A(
 		PADAPTER	pAdapter,
@@ -2794,6 +2845,12 @@ Hal_EfusePgPacketExceptionHandle_8812A(
 }
 
 
+BOOLEAN hal_EfuseCheckIfDatafollowed(
+	IN		PADAPTER		pAdapter,
+	IN		u8			word_cnts,
+	IN		u16			startAddr,
+	IN		BOOLEAN			bPseudoTest
+);
 BOOLEAN hal_EfuseCheckIfDatafollowed(
 	IN		PADAPTER		pAdapter,
 	IN		u8			word_cnts,
@@ -2813,6 +2870,12 @@ BOOLEAN hal_EfuseCheckIfDatafollowed(
 }
 
 
+BOOLEAN
+hal_EfuseWordEnMatched(
+	IN	PPGPKT_STRUCT	pTargetPkt,
+	IN	PPGPKT_STRUCT	pCurPkt,
+	IN	u8			*pWden
+);
 BOOLEAN
 hal_EfuseWordEnMatched(
 	IN	PPGPKT_STRUCT	pTargetPkt,
@@ -2849,6 +2912,14 @@ hal_EfuseWordEnMatched(
 }
 
 
+BOOLEAN
+efuse_PgPacketPartialWrite(
+	IN	    PADAPTER		pAdapter,
+	IN	    u8			efuseType,
+	IN OUT	u16			*pAddr,
+	IN	    PPGPKT_STRUCT	pTargetPkt,
+	IN	    BOOLEAN			bPseudoTest
+);
 BOOLEAN
 efuse_PgPacketPartialWrite(
 	IN	    PADAPTER		pAdapter,
@@ -3004,6 +3075,12 @@ efuse_PgPacketPartialWrite(
 	return bRet;
 }
 
+BOOLEAN	efuse_PgPacketWriteHeader(
+	PADAPTER		pAdapter,
+	u8			efuseType,
+	u16			*pAddr,
+	PPGPKT_STRUCT	pTargetPkt,
+	BOOLEAN			bPseudoTest);
 BOOLEAN	efuse_PgPacketWriteHeader(
 	PADAPTER		pAdapter,
 	u8			efuseType,
@@ -3021,6 +3098,12 @@ BOOLEAN	efuse_PgPacketWriteHeader(
 	return bRet;
 }
 
+int
+hal_EfusePgPacketWrite_8812A(IN	PADAPTER	pAdapter,
+			u8			offset,
+			u8			word_en,
+			u8			*pData,
+			BOOLEAN		bPseudoTest);
 int
 hal_EfusePgPacketWrite_8812A(IN	PADAPTER	pAdapter,
 			u8			offset,
@@ -3288,6 +3371,7 @@ void rtl8812_stop_thread(PADAPTER padapter)
 {
 }
 
+void hal_notch_filter_8812(_adapter *adapter, bool enable);
 void hal_notch_filter_8812(_adapter *adapter, bool enable)
 {
 	if (enable) {
@@ -5194,6 +5278,7 @@ struct bcn_qinfo_8812a {
 	u16 pkt_num:8;
 };
 
+void dump_qinfo_8812a(void *sel, struct qinfo_8812a *info, const char *tag);
 void dump_qinfo_8812a(void *sel, struct qinfo_8812a *info, const char *tag)
 {
 	/* if (info->pkt_num) */
@@ -5202,6 +5287,7 @@ void dump_qinfo_8812a(void *sel, struct qinfo_8812a *info, const char *tag)
 		     );
 }
 
+void dump_bcn_qinfo_8812a(void *sel, struct bcn_qinfo_8812a *info, const char *tag);
 void dump_bcn_qinfo_8812a(void *sel, struct bcn_qinfo_8812a *info, const char *tag)
 {
 	/* if (info->pkt_num) */
@@ -5210,6 +5296,7 @@ void dump_bcn_qinfo_8812a(void *sel, struct bcn_qinfo_8812a *info, const char *t
 		     );
 }
 
+void dump_mac_qinfo_8812a(void *sel, _adapter *adapter);
 void dump_mac_qinfo_8812a(void *sel, _adapter *adapter)
 {
 	u32 q0_info;
@@ -5277,6 +5364,7 @@ static void dump_mac_txfifo_8812a(void *sel, _adapter *adapter)
 	}
 }
 
+void rtl8812a_read_wmmedca_reg(PADAPTER adapter, u16 *vo_params, u16 *vi_params, u16 *be_params, u16 *bk_params);
 void rtl8812a_read_wmmedca_reg(PADAPTER adapter, u16 *vo_params, u16 *vi_params, u16 *be_params, u16 *bk_params)
 {
 	u8 vo_reg_params[4];
@@ -5447,6 +5535,7 @@ u8 SetHalDefVar8812A(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval)
 	return bResult;
 }
 
+void hal_ra_info_dump(_adapter *padapter , void *sel);
 void hal_ra_info_dump(_adapter *padapter , void *sel)
 {
 	int i;
diff --git a/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_phycfg.c b/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_phycfg.c
index 464168823..f44fb3c3e 100644
--- a/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_phycfg.c
+++ b/drivers/staging/rtl8812au/hal/rtl8812a/rtl8812a_phycfg.c
@@ -446,6 +446,13 @@ PHY_RFConfig8812(
 	return rtStatus;
 }
 
+VOID
+PHY_TxPowerTrainingByPath_8812(
+	IN	PADAPTER			Adapter,
+	IN	enum channel_width	BandWidth,
+	IN	u8					Channel,
+	IN	u8					RfPath
+);
 VOID
 PHY_TxPowerTrainingByPath_8812(
 	IN	PADAPTER			Adapter,
@@ -1097,6 +1104,11 @@ u32 phy_get_tx_bb_swing_8812a(
 	return out;
 }
 
+VOID
+phy_SetRFEReg8812(
+	IN PADAPTER		Adapter,
+	IN u8			Band
+);
 VOID
 phy_SetRFEReg8812(
 	IN PADAPTER		Adapter,
@@ -1218,6 +1230,11 @@ phy_SetRFEReg8812(
 	}
 }
 
+void phy_SetBBSwingByBand_8812A(
+	IN PADAPTER		Adapter,
+	IN u8			Band,
+	IN u1Byte		PreviousBand
+);
 void phy_SetBBSwingByBand_8812A(
 	IN PADAPTER		Adapter,
 	IN u8			Band,
@@ -1260,6 +1277,11 @@ void phy_SetBBSwingByBand_8812A(
 }
 
 
+VOID
+phy_SetRFEReg8821(
+	IN PADAPTER	Adapter,
+	IN u1Byte		Band
+);
 VOID
 phy_SetRFEReg8821(
 	IN PADAPTER	Adapter,
@@ -1459,6 +1481,11 @@ PHY_SwitchWirelessBand8812(
 	return _SUCCESS;
 }
 
+BOOLEAN
+phy_SwBand8812(
+	IN	PADAPTER	pAdapter,
+	IN	u8			channelToSW
+);
 BOOLEAN
 phy_SwBand8812(
 	IN	PADAPTER	pAdapter,
@@ -1489,6 +1516,10 @@ phy_SwBand8812(
 
 #pragma clang optimize off
 u8
+phy_GetSecondaryChnl_8812(
+	IN	PADAPTER	Adapter
+);
+u8
 phy_GetSecondaryChnl_8812(
 	IN	PADAPTER	Adapter
 )
@@ -1531,6 +1562,11 @@ phy_GetSecondaryChnl_8812(
 }
 #pragma clang optimize on
 
+VOID
+phy_SetRegBW_8812(
+	IN	PADAPTER		Adapter,
+	enum channel_width	CurrentBW
+);
 VOID
 phy_SetRegBW_8812(
 	IN	PADAPTER		Adapter,
@@ -1562,6 +1598,12 @@ phy_SetRegBW_8812(
 
 }
 
+void
+phy_FixSpur_8812A(
+	IN	PADAPTER	        pAdapter,
+	IN  enum channel_width    Bandwidth,
+	IN  u1Byte			    Channel
+);
 void
 phy_FixSpur_8812A(
 	IN	PADAPTER	        pAdapter,
@@ -1605,6 +1647,10 @@ phy_FixSpur_8812A(
 
 }
 
+VOID
+phy_PostSetBwMode8812(
+	IN	PADAPTER	Adapter
+);
 VOID
 phy_PostSetBwMode8812(
 	IN	PADAPTER	Adapter
@@ -1699,6 +1745,9 @@ phy_PostSetBwMode8812(
 }
 
 /* <20130207, Kordan> The variales initialized here are used in odm_LNAPowerControl(). */
+VOID phy_InitRssiTRSW(
+	IN	PADAPTER					pAdapter
+);
 VOID phy_InitRssiTRSW(
 	IN	PADAPTER					pAdapter
 )
@@ -1723,6 +1772,12 @@ VOID phy_InitRssiTRSW(
 
 /*Referenced from "WB-20130801-YN-RL6286 Settings for Spur Issues R02.xls"*/
 VOID
+phy_SpurCalibration_8812A(
+	IN	PADAPTER	pAdapter,
+	IN	u8			Channel,
+	IN	u8			Bandwidth
+);
+VOID
 phy_SpurCalibration_8812A(
 	IN	PADAPTER	pAdapter,
 	IN	u8			Channel,
@@ -1769,6 +1824,10 @@ phy_SpurCalibration_8812A(
 
 }
 
+VOID
+phy_SwChnl8812(
+	IN	PADAPTER	pAdapter
+);
 VOID
 phy_SwChnl8812(
 	IN	PADAPTER	pAdapter
@@ -1861,6 +1920,10 @@ phy_SwChnl8812(
 		phy_SpurCalibration_8812A(pAdapter, channelToSW, bandwidthToSw);
 }
 
+VOID
+phy_SwChnlAndSetBwMode8812(
+	IN  PADAPTER		Adapter
+);
 VOID
 phy_SwChnlAndSetBwMode8812(
 	IN  PADAPTER		Adapter
@@ -1918,6 +1981,17 @@ phy_SwChnlAndSetBwMode8812(
 	}
 }
 
+VOID
+PHY_HandleSwChnlAndSetBW8812(
+	IN	PADAPTER			Adapter,
+	IN	BOOLEAN				bSwitchChannel,
+	IN	BOOLEAN				bSetBandWidth,
+	IN	u8					ChannelNum,
+	IN	enum channel_width		ChnlWidth,
+	IN	u8					ChnlOffsetOf40MHz,
+	IN	u8					ChnlOffsetOf80MHz,
+	IN	u8					CenterFrequencyIndex1
+);
 VOID
 PHY_HandleSwChnlAndSetBW8812(
 	IN	PADAPTER			Adapter,
diff --git a/drivers/staging/rtl8812au/hal/rtl8812a/usb/usb_halinit.c b/drivers/staging/rtl8812au/hal/rtl8812a/usb/usb_halinit.c
index 37d6cec0a..d2b2b2c99 100644
--- a/drivers/staging/rtl8812au/hal/rtl8812a/usb/usb_halinit.c
+++ b/drivers/staging/rtl8812au/hal/rtl8812a/usb/usb_halinit.c
@@ -145,6 +145,7 @@ static BOOLEAN HalUsbSetQueuePipeMapping8812AUsb(
 
 }
 
+void rtl8812au_interface_configure(_adapter *padapter);
 void rtl8812au_interface_configure(_adapter *padapter)
 {
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
@@ -1116,6 +1117,10 @@ init_UsbAggregationSetting_8812A(
  *
  *---------------------------------------------------------------------------*/
 VOID
+USB_AggModeSwitch(
+	IN	PADAPTER			Adapter
+);
+VOID
 USB_AggModeSwitch(
 	IN	PADAPTER			Adapter
 )
@@ -1278,6 +1283,7 @@ HalDetectSelectiveSuspendMode(
 #endif
 }	/* HalDetectSelectiveSuspendMode */
 
+rt_rf_power_state RfOnOffDetect(IN	PADAPTER pAdapter);
 rt_rf_power_state RfOnOffDetect(IN	PADAPTER pAdapter)
 {
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(pAdapter);
@@ -1298,12 +1304,14 @@ rt_rf_power_state RfOnOffDetect(IN	PADAPTER pAdapter)
 	return rfpowerstate;
 }	/* HalDetectPwrDownMode */
 
+void _ps_open_RF(_adapter *padapter);
 void _ps_open_RF(_adapter *padapter)
 {
 	/* here call with bRegSSPwrLvl 1, bRegSSPwrLvl 2 needs to be verified */
 	/* phy_SsPwrSwitch92CU(padapter, rf_on, 1); */
 }
 
+void _ps_close_RF(_adapter *padapter);
 void _ps_close_RF(_adapter *padapter)
 {
 	/* here call with bRegSSPwrLvl 1, bRegSSPwrLvl 2 needs to be verified */
@@ -1353,6 +1361,7 @@ static void rtl8812au_hw_reset(_adapter *Adapter)
 	}
 }
 
+u32 rtl8812au_hal_init(PADAPTER Adapter);
 u32 rtl8812au_hal_init(PADAPTER Adapter)
 {
 	u8	value8 = 0, u1bRegCR;
@@ -1804,6 +1813,10 @@ u32 rtl8812au_hal_init(PADAPTER Adapter)
 	return status;
 }
 
+VOID
+hal_poweroff_8812au(
+	IN	PADAPTER			Adapter
+);
 VOID
 hal_poweroff_8812au(
 	IN	PADAPTER			Adapter
@@ -1872,6 +1885,7 @@ static void rtl8812au_hw_power_down(_adapter *padapter)
 	rtw_write16(padapter, REG_APS_FSMCO, 0x8812);
 }
 
+u32 rtl8812au_hal_deinit(PADAPTER Adapter);
 u32 rtl8812au_hal_deinit(PADAPTER Adapter)
 {
 	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(Adapter);
@@ -1922,7 +1936,8 @@ u32 rtl8812au_hal_deinit(PADAPTER Adapter)
 }
 
 
-unsigned int rtl8812au_inirp_init(PADAPTER Adapter)
+unsigned int rtl8812au_inirp_init(PADAPTER Adapter);
+unsigned int rtl8812au_inirp_init(PADAPTER Adapter)
 {
 	u8 i;
 	struct recv_buf *precvbuf;
@@ -1976,7 +1991,8 @@ unsigned int rtl8812au_inirp_init(PADAPTER Adapter)
 
 }
 
-unsigned int rtl8812au_inirp_deinit(PADAPTER Adapter)
+unsigned int rtl8812au_inirp_deinit(PADAPTER Adapter);
+unsigned int rtl8812au_inirp_deinit(PADAPTER Adapter)
 {
 
 	rtw_read_port_cancel(Adapter);
@@ -1991,6 +2007,12 @@ unsigned int rtl8812au_inirp_deinit(PADAPTER Adapter)
  *
  * ------------------------------------------------------------------- */
 VOID
+hal_ReadIDs_8812AU(
+	IN	PADAPTER	Adapter,
+	IN	pu1Byte		PROMContent,
+	IN	BOOLEAN		AutoloadFail
+);
+VOID
 hal_ReadIDs_8812AU(
 	IN	PADAPTER	Adapter,
 	IN	pu1Byte		PROMContent,
@@ -2049,6 +2071,11 @@ hal_ReadIDs_8812AU(
 	RTW_INFO("Customer ID: 0x%02X, SubCustomer ID: 0x%02X\n", pHalData->EEPROMCustomerID, pHalData->EEPROMSubCustomerID);
 }
 
+VOID
+hal_InitPGData_8812A(
+	IN	PADAPTER		padapter,
+	IN	OUT	u8			*PROMContent
+);
 VOID
 hal_InitPGData_8812A(
 	IN	PADAPTER		padapter,
@@ -2127,6 +2154,10 @@ hal_InitPGData_8812A(
 
 }
 
+VOID
+hal_CustomizedBehavior_8812AU(
+	IN	PADAPTER	Adapter
+);
 VOID
 hal_CustomizedBehavior_8812AU(
 	IN	PADAPTER	Adapter
@@ -2266,6 +2297,12 @@ hal_CustomizeByCustomerID_8812AU(
 	hal_CustomizedBehavior_8812AU(pAdapter);
 }
 
+VOID
+hal_ReadUsbModeSwitch_8812AU(
+	IN	PADAPTER	Adapter,
+	IN	u8			*PROMContent,
+	IN	BOOLEAN		AutoloadFail
+);
 VOID
 hal_ReadUsbModeSwitch_8812AU(
 	IN	PADAPTER	Adapter,
@@ -2302,6 +2339,10 @@ ReadLEDSetting_8812AU(
 #endif
 }
 
+VOID
+InitAdapterVariablesByPROM_8812AU(
+	IN	PADAPTER	Adapter
+);
 VOID
 InitAdapterVariablesByPROM_8812AU(
 	IN	PADAPTER	Adapter
@@ -2372,6 +2413,10 @@ static void Hal_ReadPROMContent_8812A(
 	InitAdapterVariablesByPROM_8812AU(Adapter);
 }
 
+u8
+ReadAdapterInfo8812AU(
+	IN PADAPTER			Adapter
+);
 u8
 ReadAdapterInfo8812AU(
 	IN PADAPTER			Adapter
@@ -2386,6 +2431,7 @@ ReadAdapterInfo8812AU(
 	return _SUCCESS;
 }
 
+void UpdateInterruptMask8812AU(PADAPTER padapter, u8 bHIMR0 , u32 AddMSR, u32 RemoveMSR);
 void UpdateInterruptMask8812AU(PADAPTER padapter, u8 bHIMR0 , u32 AddMSR, u32 RemoveMSR)
 {
 	HAL_DATA_TYPE *pHalData;
@@ -2411,6 +2457,7 @@ void UpdateInterruptMask8812AU(PADAPTER padapter, u8 bHIMR0 , u32 AddMSR, u32 Re
 
 }
 
+u8 SetHwReg8812AU(PADAPTER Adapter, u8 variable, u8 *val);
 u8 SetHwReg8812AU(PADAPTER Adapter, u8 variable, u8 *val)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
@@ -2500,6 +2547,7 @@ u8 SetHwReg8812AU(PADAPTER Adapter, u8 variable, u8 *val)
 	return ret;
 }
 
+void GetHwReg8812AU(PADAPTER Adapter, u8 variable, u8 *val);
 void GetHwReg8812AU(PADAPTER Adapter, u8 variable, u8 *val)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
@@ -2531,6 +2579,12 @@ void GetHwReg8812AU(PADAPTER Adapter, u8 variable, u8 *val)
  *		Change default setting of specified variable.
  *   */
 u8
+SetHalDefVar8812AUsb(
+	IN	PADAPTER				Adapter,
+	IN	HAL_DEF_VARIABLE		eVariable,
+	IN	PVOID					pValue
+);
+u8
 SetHalDefVar8812AUsb(
 	IN	PADAPTER				Adapter,
 	IN	HAL_DEF_VARIABLE		eVariable,
@@ -2554,6 +2608,12 @@ SetHalDefVar8812AUsb(
  *		Query setting of specified variable.
  *   */
 u8
+GetHalDefVar8812AUsb(
+	IN	PADAPTER				Adapter,
+	IN	HAL_DEF_VARIABLE		eVariable,
+	IN	PVOID					pValue
+);
+u8
 GetHalDefVar8812AUsb(
 	IN	PADAPTER				Adapter,
 	IN	HAL_DEF_VARIABLE		eVariable,
@@ -2572,6 +2632,7 @@ GetHalDefVar8812AUsb(
 	return bResult;
 }
 
+void _update_response_rate(_adapter *padapter, unsigned int mask);
 void _update_response_rate(_adapter *padapter, unsigned int mask)
 {
 	u8	RateIndex = 0;
diff --git a/drivers/staging/rtl8812au/hal/rtl8812a/usb/usb_ops_linux.c b/drivers/staging/rtl8812au/hal/rtl8812a/usb/usb_ops_linux.c
index 22f8c42cf..db7f3b2c5 100644
--- a/drivers/staging/rtl8812au/hal/rtl8812a/usb/usb_ops_linux.c
+++ b/drivers/staging/rtl8812au/hal/rtl8812a/usb/usb_ops_linux.c
@@ -101,6 +101,7 @@ void interrupt_handler_8812au(_adapter *padapter, u16 pkt_len, u8 *pbuf)
 }
 #endif
 
+int recvbuf2recvframe(PADAPTER padapter, void *ptr);
 int recvbuf2recvframe(PADAPTER padapter, void *ptr)
 {
 	u8	*pbuf;
diff --git a/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_cmd.c b/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_cmd.c
index 6aa1fda17..76ed34e50 100644
--- a/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_cmd.c
+++ b/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_cmd.c
@@ -151,6 +151,7 @@ s32 FillH2CCmd_8814(PADAPTER padapter, u8 ElementID, u32 CmdLen, u8 *pCmdBuffer)
 	return ret;
 }
 
+u8 rtl8814_set_rssi_cmd(_adapter*padapter, u8 *param);
 u8 rtl8814_set_rssi_cmd(_adapter*padapter, u8 *param)
 {
 	u8	res=_SUCCESS;
@@ -206,6 +207,13 @@ static u8	Get_VHT_ENI(
 	return (Ret << 4);
 }
 
+BOOLEAN 
+Get_RA_ShortGI_8814(	
+	PADAPTER			Adapter,
+	struct sta_info		*psta,
+	u8					shortGIrate,
+	u32					ratr_bitmap
+);
 BOOLEAN 
 Get_RA_ShortGI_8814(	
 	PADAPTER			Adapter,
@@ -267,6 +275,10 @@ Set_RA_LDPC_8814(
 }
 
 
+u8 
+Get_RA_LDPC_8814(
+	struct sta_info		*psta
+);
 u8 
 Get_RA_LDPC_8814(
 	struct sta_info		*psta
@@ -597,6 +609,7 @@ static void ConstructNullFunctionData(
 	*pLength = pktlen;
 }
 
+void ConstructProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr, BOOLEAN bHideSSID);
 void ConstructProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr, BOOLEAN bHideSSID)
 {
 	struct rtw_ieee80211_hdr	*pwlanhdr;
@@ -1152,6 +1165,7 @@ static void rtl8814_set_FwAoacRsvdPage_cmd(PADAPTER padapter, PRSVDPAGE_LOC rsvd
 #endif
 
 
+int rtl8814_iqk_wait(_adapter* padapter, u32 timeout_ms);
 int rtl8814_iqk_wait(_adapter* padapter, u32 timeout_ms)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
@@ -1164,6 +1178,7 @@ int rtl8814_iqk_wait(_adapter* padapter, u32 timeout_ms)
 	return rtw_sctx_wait(iqk_sctx, __func__);
 }
 
+void rtl8814_iqk_done(_adapter* padapter);
 void rtl8814_iqk_done(_adapter* padapter)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
diff --git a/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_hal_init.c b/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_hal_init.c
index f1a903d68..d203753b6 100644
--- a/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_hal_init.c
+++ b/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_hal_init.c
@@ -119,6 +119,11 @@ void hal_DetectWoWMode(PADAPTER pAdapter)
 #endif
 
 
+VOID
+_FWDownloadEnable_8814A(
+	IN	PADAPTER		Adapter,
+	IN	BOOLEAN			enable
+	);
 VOID
 _FWDownloadEnable_8814A(
 	IN	PADAPTER		Adapter,
@@ -152,6 +157,12 @@ _FWDownloadEnable_8814A(
 
 #define MAX_REG_BOLCK_SIZE	196
 
+VOID
+_BlockWrite_8814A(
+	IN		PADAPTER		Adapter,
+	IN		PVOID			buffer,
+	IN		u32			buffSize
+	);
 VOID
 _BlockWrite_8814A(
 	IN		PADAPTER		Adapter,
@@ -212,6 +223,13 @@ _BlockWrite_8814A(
 	}
 }
 
+VOID
+_PageWrite_8814A(
+	IN		PADAPTER		Adapter,
+	IN		u32			page,
+	IN		PVOID			buffer,
+	IN		u32			size
+	);
 VOID
 _PageWrite_8814A(
 	IN		PADAPTER		Adapter,
@@ -229,6 +247,11 @@ _PageWrite_8814A(
 	_BlockWrite_8814A(Adapter,buffer,size);
 }
 
+VOID
+_FillDummy_8814A(
+	u8*		pFwBuf,
+	pu4Byte		pFwLen
+	);
 VOID
 _FillDummy_8814A(
 	u8*		pFwBuf,
@@ -249,6 +272,12 @@ _FillDummy_8814A(
 	*pFwLen = FwLen;
 }
 
+VOID
+_WriteFW_8814A(
+	IN		PADAPTER		Adapter,
+	IN		PVOID			buffer,
+	IN		u32			size
+	);
 VOID
 _WriteFW_8814A(
 	IN		PADAPTER		Adapter,
@@ -284,6 +313,10 @@ _WriteFW_8814A(
 	}	
 }
 
+VOID
+_3081Disable8814A(
+	IN	PADAPTER		Adapter
+	);
 VOID
 _3081Disable8814A(
 	IN	PADAPTER		Adapter
@@ -296,6 +329,10 @@ _3081Disable8814A(
 
 }
 
+VOID
+_3081Enable8814A(
+	IN	PADAPTER		Adapter
+	);
 VOID
 _3081Enable8814A(
 	IN	PADAPTER		Adapter
@@ -453,6 +490,12 @@ WaitDownLoadRSVDPageOK_3081(
 }
 
 
+VOID
+SetDownLoadFwRsvdPagePkt_8814A(
+	IN PADAPTER		Adapter,
+	IN PVOID			buffer,
+	IN u32		len
+	);
 VOID
 SetDownLoadFwRsvdPagePkt_8814A(
 	IN PADAPTER		Adapter,
@@ -535,6 +578,12 @@ static void SetBcnCtrlReg(
 	rtw_write8(padapter, REG_BCN_CTRL, RegBcnCtrlVal);
 }
 
+VOID
+HalROMDownloadFWRSVDPage8814A(
+	IN	PADAPTER			Adapter,
+	IN	PVOID				buffer,
+	IN	u32				Len
+);
 VOID
 HalROMDownloadFWRSVDPage8814A(
 	IN	PADAPTER			Adapter,
@@ -726,6 +775,10 @@ HalROMDownloadFWRSVDPage8814A(
 	}
 }
 
+s32
+_FWFreeToGo8814A(
+	IN		PADAPTER		Adapter
+	);
 s32
 _FWFreeToGo8814A(
 	IN		PADAPTER		Adapter
@@ -1444,6 +1497,11 @@ SetFwRelatedForWoWLAN8812(
 //				Efuse related code
 //===========================================================
 BOOLEAN 
+hal_GetChnlGroup8814A(
+	IN	u8 Channel,
+	OUT u8*	pGroup
+	);
+BOOLEAN 
 hal_GetChnlGroup8814A(
 	IN	u8 Channel,
 	OUT u8*	pGroup
@@ -1774,6 +1832,10 @@ hal_ReadPowerValueFromPROM8814A(
 }
 #endif
 
+VOID
+HALBT_InitHalVars(
+	IN	PADAPTER	Adapter
+	);
 VOID
 HALBT_InitHalVars(
 	IN	PADAPTER	Adapter
@@ -1792,6 +1854,10 @@ HALBT_InitHalVars(
 }
 
 
+VOID 
+BT_InitHalVars(
+	IN	PADAPTER			Adapter
+	);
 VOID 
 BT_InitHalVars(
 	IN	PADAPTER			Adapter
@@ -2789,6 +2855,13 @@ rtl8814_ReadEFuse(
 
 //Do not support BT
 VOID
+hal_EFUSEGetEfuseDefinition8814A(
+	IN		PADAPTER	pAdapter,
+	IN		u8		efuseType,
+	IN		u8		type,
+	OUT		PVOID		pOut
+	);
+VOID
 hal_EFUSEGetEfuseDefinition8814A(
 	IN		PADAPTER	pAdapter,
 	IN		u8		efuseType,
@@ -3231,6 +3304,11 @@ efuse_PgPacketConstruct(
 }
 
 
+u16
+efuse_PgPacketExceptionHandle(
+					IN	PADAPTER		pAdapter,
+					IN	u16			ErrOffset
+					);
 u16
 efuse_PgPacketExceptionHandle(
 					IN	PADAPTER		pAdapter,
@@ -3528,6 +3606,13 @@ hal_EfuseFixHeaderProcess(
 }
 
 
+BOOLEAN
+efuse_PgPacketWrite2ByteHeader(
+	IN			PADAPTER		pAdapter,
+	IN			u8			efuseType,
+	IN OUT		u16*			pAddr,
+	IN			PPGPKT_STRUCT	pTargetPkt,
+	IN			BOOLEAN			bPseudoTest);
 BOOLEAN
 efuse_PgPacketWrite2ByteHeader(
 	IN			PADAPTER		pAdapter,
@@ -3631,6 +3716,13 @@ efuse_PgPacketWrite2ByteHeader(
 }
 
 
+BOOLEAN
+efuse_PgPacketWrite1ByteHeader(
+	IN			PADAPTER		pAdapter, 
+	IN			u8			efuseType,
+	IN OUT		u16*			pAddr,
+	IN			PPGPKT_STRUCT	pTargetPkt,
+	IN			BOOLEAN			bPseudoTest);
 BOOLEAN
 efuse_PgPacketWrite1ByteHeader(
 	IN			PADAPTER		pAdapter, 
@@ -3724,6 +3816,13 @@ efuse_PgPacketWriteHeader(
 	return bRet;
 }
 
+BOOLEAN
+efuse_PgPacketWriteData(
+	IN			PADAPTER		pAdapter, 
+	IN			u8			efuseType,
+	IN			u16*			pAddr,
+	IN			PPGPKT_STRUCT	pTargetPkt,
+	IN			BOOLEAN			bPseudoTest);
 BOOLEAN
 efuse_PgPacketWriteData(
 	IN			PADAPTER		pAdapter, 
@@ -3760,6 +3859,12 @@ efuse_PgPacketWriteData(
 }
 
 
+int
+hal_EfusePgPacketWrite_8814A(IN	PADAPTER	pAdapter,
+					IN	u8 			offset,
+					IN	u8			word_en,
+					IN	u8			*pData,
+					IN	BOOLEAN		bPseudoTest);
 int
 hal_EfusePgPacketWrite_8814A(IN	PADAPTER	pAdapter,
 					IN	u8 			offset,
@@ -3871,6 +3976,7 @@ void rtl8814_stop_thread(PADAPTER padapter)
 {
 }
 
+void hal_notch_filter_8814(_adapter *adapter, bool enable);
 void hal_notch_filter_8814(_adapter *adapter, bool enable)
 {
 	if (enable) {
@@ -3918,6 +4024,7 @@ void CheckAutoloadState8812A(PADAPTER padapter)
 }
 */
 
+void InitPGData8814A(PADAPTER padapter);
 void InitPGData8814A(PADAPTER padapter)
 {
 	u32 i;
@@ -3997,6 +4104,11 @@ static void read_chip_version_8814a(PADAPTER Adapter)
 
 }
 
+VOID
+hal_PatchwithJaguar_8814(
+	IN PADAPTER				Adapter,
+	IN RT_MEDIA_STATUS		MediaStatus
+	);
 VOID
 hal_PatchwithJaguar_8814(
 	IN PADAPTER				Adapter,
@@ -6300,6 +6412,7 @@ struct bcn_qinfo_8814a {
 	u16 pkt_num:8;
 };
 
+void dump_qinfo_8814a(void *sel, struct qinfo_8814a *info, const char *tag);
 void dump_qinfo_8814a(void *sel, struct qinfo_8814a *info, const char *tag)
 {
 	//if (info->pkt_num)
@@ -6308,6 +6421,7 @@ void dump_qinfo_8814a(void *sel, struct qinfo_8814a *info, const char *tag)
 	);
 }
 
+void dump_bcn_qinfo_8814a(void *sel, struct bcn_qinfo_8814a *info, const char *tag);
 void dump_bcn_qinfo_8814a(void *sel, struct bcn_qinfo_8814a *info, const char *tag)
 {
 	//if (info->pkt_num)
@@ -6316,6 +6430,7 @@ void dump_bcn_qinfo_8814a(void *sel, struct bcn_qinfo_8814a *info, const char *t
 	);
 }
 
+void dump_mac_qinfo_8814a(void *sel, _adapter *adapter);
 void dump_mac_qinfo_8814a(void *sel, _adapter *adapter)
 {
 	u32 q0_info;
diff --git a/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c b/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c
index 1c212540c..675a0591b 100644
--- a/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c
+++ b/drivers/staging/rtl8812au/hal/rtl8814a/rtl8814a_phycfg.c
@@ -1102,6 +1102,10 @@ PHY_SetRFPowerState8814A(
 todo */
 //1 5. Tx  Power setting API
 
+VOID
+phy_TxPwrAdjInPercentage(
+	IN		PADAPTER		Adapter,
+	OUT		u8*				pTxPwrIdx);
 VOID
 phy_TxPwrAdjInPercentage(
 	IN		PADAPTER		Adapter,
@@ -1455,7 +1459,13 @@ phy_SetBwRegAdc_8814A(
 	IN	PADAPTER		Adapter,
 	IN	u8			Band,
 	IN	enum channel_width 	CurrentBW
-)	
+);
+VOID
+phy_SetBwRegAdc_8814A(
+	IN	PADAPTER		Adapter,
+	IN	u8			Band,
+	IN	enum channel_width 	CurrentBW
+)
 {
 	switch(CurrentBW)
 	{
@@ -1497,7 +1507,13 @@ phy_SetBwRegAgc_8814A(
 	IN	PADAPTER		Adapter,
 	IN	u8			Band,
 	IN	enum channel_width 	CurrentBW
-)	
+);
+VOID
+phy_SetBwRegAgc_8814A(
+	IN	PADAPTER		Adapter,
+	IN	u8			Band,
+	IN	enum channel_width 	CurrentBW
+)
 {
 	u32 AgcValue = 7;
 	switch(CurrentBW)
@@ -1529,6 +1545,10 @@ phy_SetBwRegAgc_8814A(
 }
 
 
+BOOLEAN
+phy_SwBand8814A(
+	IN	PADAPTER	pAdapter,
+	IN	u8			channelToSW);
 BOOLEAN
 phy_SwBand8814A(
 	IN	PADAPTER	pAdapter,
@@ -1648,6 +1668,12 @@ PHY_SetRFEReg8814A(
 	}
 }
 
+VOID 
+phy_SetBBSwingByBand_8814A(
+	IN PADAPTER		Adapter,
+	IN u8		Band,
+	IN u8		PreviousBand
+	);
 VOID 
 phy_SetBBSwingByBand_8814A(
 	IN PADAPTER		Adapter,
@@ -1766,6 +1792,10 @@ PHY_SwitchWirelessBand8814A(
 }
 
 
+u8 
+phy_GetSecondaryChnl_8814A(
+	IN	PADAPTER	Adapter
+);
 u8 
 phy_GetSecondaryChnl_8814A(
 	IN	PADAPTER	Adapter
@@ -1823,7 +1853,12 @@ VOID
 phy_SetBwRegMac_8814A(
 	IN	PADAPTER		Adapter,
 	enum channel_width 	CurrentBW
-)	
+);
+VOID
+phy_SetBwRegMac_8814A(
+	IN	PADAPTER		Adapter,
+	enum channel_width 	CurrentBW
+)
 {
 	u16		RegRfMod_BW, u2tmp = 0;
 	RegRfMod_BW = PlatformEFIORead2Byte(Adapter, REG_TRXPTCL_CTL_8814A);
@@ -1974,7 +2009,8 @@ void PHY_Set_SecCCATH_by_RXANT_8814A(PADAPTER	pAdapter,u4Byte	ulAntennaRx)
 }
 
 
-VOID PHY_SetRXSC_by_TXSC_8814A(PADAPTER	Adapter, u1Byte SubChnlNum)	
+VOID PHY_SetRXSC_by_TXSC_8814A(PADAPTER	Adapter, u1Byte SubChnlNum);
+VOID PHY_SetRXSC_by_TXSC_8814A(PADAPTER	Adapter, u1Byte SubChnlNum)
 {
 	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(Adapter);
 
@@ -2004,6 +2040,7 @@ VOID PHY_SetRXSC_by_TXSC_8814A(PADAPTER	Adapter, u1Byte SubChnlNum)
 
 
 /* <20141230, James> A workaround to eliminate the 5280MHz & 5600MHz & 5760MHzspur of 8814A. (Asked by BBSD Neil.)*/
+VOID phy_SpurCalibration_8814A(PADAPTER	Adapter);
 VOID phy_SpurCalibration_8814A(PADAPTER	Adapter)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
@@ -2125,6 +2162,8 @@ VOID phy_SpurCalibration_8814A(PADAPTER	Adapter)
 }
 
 
+void phy_ModifyInitialGain_8814A(
+	PADAPTER		Adapter);
 void phy_ModifyInitialGain_8814A(
 	PADAPTER		Adapter)
 {
@@ -2179,6 +2218,7 @@ void phy_ModifyInitialGain_8814A(
 }
 
 
+VOID phy_SetBwMode8814A(PADAPTER	Adapter);
 VOID phy_SetBwMode8814A(PADAPTER	Adapter)
 {
 	u8			SubChnlNum = 0;
@@ -2445,6 +2485,10 @@ phy_ConfigKFree8814A(
 }
 #endif 
 VOID
+phy_SwChnl8814A(	
+	IN	PADAPTER					pAdapter
+	);
+VOID
 phy_SwChnl8814A(	
 	IN	PADAPTER					pAdapter
 	)
@@ -2658,6 +2702,10 @@ HAL_HandleSwChnl8814A(	// Call after initialization
 }
 */
 
+VOID
+phy_SwChnlAndSetBwMode8814A(
+	IN  PADAPTER		Adapter
+);
 VOID
 phy_SwChnlAndSetBwMode8814A(
 	IN  PADAPTER		Adapter
@@ -2980,6 +3028,12 @@ SetAntennaConfig8814A(
 	return TRUE;
 }
 
+VOID
+PHY_SetBWMode8814(
+	IN	PADAPTER			Adapter,
+	IN	enum channel_width	Bandwidth,	// 20M or 40M
+	IN	u8					Offset		// Upper, Lower, or Don't care
+);
 VOID
 PHY_SetBWMode8814(
 	IN	PADAPTER			Adapter,
@@ -2996,6 +3050,11 @@ PHY_SetBWMode8814(
 	//RTW_INFO("<==%s()\n",__FUNCTION__);
 }
 
+VOID
+PHY_SwChnl8814(
+	IN	PADAPTER	Adapter,
+	IN	u8			channel
+	);
 VOID
 PHY_SwChnl8814(
 	IN	PADAPTER	Adapter,
diff --git a/drivers/staging/rtl8812au/hal/rtl8814a/usb/usb_halinit.c b/drivers/staging/rtl8812au/hal/rtl8814a/usb/usb_halinit.c
index 5c0bf0d03..f08839b93 100644
--- a/drivers/staging/rtl8812au/hal/rtl8814a/usb/usb_halinit.c
+++ b/drivers/staging/rtl8812au/hal/rtl8814a/usb/usb_halinit.c
@@ -102,6 +102,7 @@ static BOOLEAN HalUsbSetQueuePipeMapping8814AUsb(
 
 }
 
+void rtl8814au_interface_configure(_adapter *padapter);
 void rtl8814au_interface_configure(_adapter *padapter)
 {
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(padapter);
@@ -229,6 +230,10 @@ _InitBurstPktLen(IN PADAPTER Adapter)
 }
 
 
+VOID
+_InitQueueReservedPage_8814AUsb(
+	IN  PADAPTER 	Adapter
+	);
 VOID
 _InitQueueReservedPage_8814AUsb(
 	IN  PADAPTER 	Adapter
@@ -1216,6 +1221,7 @@ static void rtl8814au_hw_reset(_adapter *Adapter)
 #endif //0
 }
 
+u32 rtl8814au_hal_init(PADAPTER Adapter);
 u32 rtl8814au_hal_init(PADAPTER Adapter)
 {
 	u8	value8 = 0, u1bRegCR;
@@ -1697,6 +1703,10 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);
 	return status;
 }
 
+VOID
+hal_carddisable_8814(
+	IN	PADAPTER			Adapter 
+);
 VOID
 hal_carddisable_8814(
 	IN	PADAPTER			Adapter 
@@ -1726,8 +1736,9 @@ static void rtl8814au_hw_power_down(_adapter *padapter)
 	rtw_write16(padapter, REG_APS_FSMCO, 0x8812);
 }
 
+u32 rtl8814au_hal_deinit(PADAPTER Adapter);
 u32 rtl8814au_hal_deinit(PADAPTER Adapter)
- {
+{
 	struct pwrctrl_priv *pwrctl = adapter_to_pwrctl(Adapter);
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
    	RTW_INFO("==> %s \n",__FUNCTION__);
@@ -1781,7 +1792,8 @@ u32 rtl8814au_hal_deinit(PADAPTER Adapter)
  }
 
 
-unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
+unsigned int rtl8814au_inirp_init(PADAPTER Adapter);
+unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
 {	
 	u8 i;	
 	struct recv_buf *precvbuf;
@@ -1840,7 +1852,8 @@ unsigned int rtl8814au_inirp_init(PADAPTER Adapter)
 
 }
 
-unsigned int rtl8814au_inirp_deinit(PADAPTER Adapter)
+unsigned int rtl8814au_inirp_deinit(PADAPTER Adapter);
+unsigned int rtl8814au_inirp_deinit(PADAPTER Adapter)
 {	
 	RTW_INFO("\n ===> usb_rx_deinit \n");
 	
@@ -1857,6 +1870,12 @@ unsigned int rtl8814au_inirp_deinit(PADAPTER Adapter)
 //
 //-------------------------------------------------------------------
 VOID
+hal_ReadIDs_8814AU(
+	IN	PADAPTER	Adapter,
+	IN	pu1Byte		PROMContent,
+	IN	BOOLEAN		AutoloadFail
+	);
+VOID
 hal_ReadIDs_8814AU(
 	IN	PADAPTER	Adapter,
 	IN	pu1Byte		PROMContent,
@@ -1923,6 +1942,10 @@ hal_InitPGData_8814A(
 #endif
 }
 
+VOID
+hal_CustomizedBehavior_8814AU(
+	IN	PADAPTER	Adapter
+	);
 VOID
 hal_CustomizedBehavior_8814AU(
 	IN	PADAPTER	Adapter
@@ -1999,6 +2022,12 @@ hal_CustomizeByCustomerID_8814AU(
 	hal_CustomizedBehavior_8814AU(pAdapter);
 }
 
+VOID
+hal_ReadUsbModeSwitch_8814AU(
+	IN	PADAPTER	Adapter,
+	IN	u8*			PROMContent,
+	IN	BOOLEAN		AutoloadFail
+	);
 VOID
 hal_ReadUsbModeSwitch_8814AU(
 	IN	PADAPTER	Adapter,
@@ -2032,6 +2061,10 @@ ReadLEDSetting_8814AU(
 #endif //CONFIG_RTW_LED
 }
 
+VOID
+InitAdapterVariablesByPROM_8814AU(
+	IN	PADAPTER	Adapter
+	);
 VOID
 InitAdapterVariablesByPROM_8814AU(
 	IN	PADAPTER	Adapter
@@ -2091,6 +2124,10 @@ static void hal_ReadPROMContent_8814A(
 	InitAdapterVariablesByPROM_8814AU(Adapter);
 }
 
+u8
+ReadAdapterInfo8814AU(
+	IN PADAPTER			Adapter
+	);
 u8
 ReadAdapterInfo8814AU(
 	IN PADAPTER			Adapter
@@ -2107,6 +2144,7 @@ ReadAdapterInfo8814AU(
 	return _SUCCESS;
 }
 
+void UpdateInterruptMask8814AU(PADAPTER padapter,u8 bHIMR0 ,u32 AddMSR, u32 RemoveMSR);
 void UpdateInterruptMask8814AU(PADAPTER padapter,u8 bHIMR0 ,u32 AddMSR, u32 RemoveMSR)
 {
 	HAL_DATA_TYPE *pHalData;
@@ -2132,6 +2170,7 @@ void UpdateInterruptMask8814AU(PADAPTER padapter,u8 bHIMR0 ,u32 AddMSR, u32 Remo
 
 }
 
+u8 SetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val);
 u8 SetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
@@ -2221,6 +2260,7 @@ u8 SetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 	return ret;
 }
 
+void GetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val);
 void GetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
@@ -2239,6 +2279,12 @@ void GetHwReg8814AU(PADAPTER Adapter, u8 variable, u8* val)
 //		Change default setting of specified variable.
 //
 u8
+SetHalDefVar8814AUsb(
+	IN	PADAPTER				Adapter,
+	IN	HAL_DEF_VARIABLE		eVariable,
+	IN	PVOID					pValue
+	);
+u8
 SetHalDefVar8814AUsb(
 	IN	PADAPTER				Adapter,
 	IN	HAL_DEF_VARIABLE		eVariable,
@@ -2263,6 +2309,12 @@ SetHalDefVar8814AUsb(
 //		Query setting of specified variable.
 //
 u8
+GetHalDefVar8814AUsb(
+	IN	PADAPTER				Adapter,
+	IN	HAL_DEF_VARIABLE		eVariable,
+	IN	PVOID					pValue
+	);
+u8
 GetHalDefVar8814AUsb(
 	IN	PADAPTER				Adapter,
 	IN	HAL_DEF_VARIABLE		eVariable,
diff --git a/drivers/staging/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c b/drivers/staging/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c
index 320024cae..1f0ca9682 100644
--- a/drivers/staging/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c
+++ b/drivers/staging/rtl8812au/hal/rtl8814a/usb/usb_ops_linux.c
@@ -273,6 +273,7 @@ void rtl8814au_xmit_tasklet(void *priv)
 
 }
 
+void rtl8814au_set_intf_ops(struct _io_ops	*pops);
 void rtl8814au_set_intf_ops(struct _io_ops	*pops)
 {
 	_rtw_memset((u8 *)pops, 0, sizeof(struct _io_ops));
diff --git a/drivers/staging/rtl8812au/os_dep/linux/ioctl_cfg80211.c b/drivers/staging/rtl8812au/os_dep/linux/ioctl_cfg80211.c
index 6f5d97a11..ae4202ad4 100644
--- a/drivers/staging/rtl8812au/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/staging/rtl8812au/os_dep/linux/ioctl_cfg80211.c
@@ -428,6 +428,7 @@ static void rtw_get_chbw_from_cfg80211_chan_def(struct cfg80211_chan_def *chdef,
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)) */
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0))
+bool rtw_cfg80211_allow_ch_switch_notify(_adapter *adapter);
 bool rtw_cfg80211_allow_ch_switch_notify(_adapter *adapter)
 {
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0))
@@ -505,16 +506,19 @@ u8 rtw_cfg80211_ch_switch_notify(_adapter *adapter, u8 ch, u8 bw, u8 offset,
 }
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)) */
 
+void rtw_2g_channels_init(struct ieee80211_channel *channels);
 void rtw_2g_channels_init(struct ieee80211_channel *channels)
 {
 	_rtw_memcpy((void *)channels, (void *)rtw_2ghz_channels, sizeof(rtw_2ghz_channels));
 }
 
+void rtw_5g_channels_init(struct ieee80211_channel *channels);
 void rtw_5g_channels_init(struct ieee80211_channel *channels)
 {
 	_rtw_memcpy((void *)channels, (void *)rtw_5ghz_a_channels, sizeof(rtw_5ghz_a_channels));
 }
 
+void rtw_2g_rates_init(struct ieee80211_rate *rates);
 void rtw_2g_rates_init(struct ieee80211_rate *rates)
 {
 	_rtw_memcpy(rates, rtw_g_rates,
@@ -522,6 +526,7 @@ void rtw_2g_rates_init(struct ieee80211_rate *rates)
 	);
 }
 
+void rtw_5g_rates_init(struct ieee80211_rate *rates);
 void rtw_5g_rates_init(struct ieee80211_rate *rates)
 {
 	_rtw_memcpy(rates, rtw_a_rates,
@@ -572,6 +577,7 @@ struct ieee80211_supported_band *rtw_spt_band_alloc(BAND_TYPE band)
 	return spt_band;
 }
 
+void rtw_spt_band_free(struct ieee80211_supported_band *spt_band);
 void rtw_spt_band_free(struct ieee80211_supported_band *spt_band)
 {
 	u32 size = 0;
@@ -660,6 +666,7 @@ static const struct ieee80211_txrx_stypes
 };
 #endif
 
+NDIS_802_11_NETWORK_INFRASTRUCTURE nl80211_iftype_to_rtw_network_type(enum nl80211_iftype type);
 NDIS_802_11_NETWORK_INFRASTRUCTURE nl80211_iftype_to_rtw_network_type(enum nl80211_iftype type)
 {
 	switch (type) {
@@ -693,6 +700,7 @@ NDIS_802_11_NETWORK_INFRASTRUCTURE nl80211_iftype_to_rtw_network_type(enum nl802
 	}
 }
 
+u32 nl80211_iftype_to_rtw_mlme_state(enum nl80211_iftype type);
 u32 nl80211_iftype_to_rtw_mlme_state(enum nl80211_iftype type)
 {
 	switch (type) {
@@ -2711,6 +2719,7 @@ void rtw_cfg80211_unlink_bss(_adapter *padapter, struct wlan_network *pnetwork)
 }
 
 /* if target wps scan ongoing, target_ssid is filled */
+int rtw_cfg80211_is_target_wps_scan(struct cfg80211_scan_request *scan_req, struct cfg80211_ssid *target_ssid);
 int rtw_cfg80211_is_target_wps_scan(struct cfg80211_scan_request *scan_req, struct cfg80211_ssid *target_ssid)
 {
 	int ret = 0;
@@ -5420,6 +5429,7 @@ const char *_nl80211_mesh_power_mode_str[] = {
 #define nl80211_mesh_power_mode_str(_p) ((_p <= NL80211_MESH_POWER_MAX) ? _nl80211_mesh_power_mode_str[_p] : _nl80211_mesh_power_mode_str[0])
 #endif
 
+void dump_station_parameters(void *sel, struct wiphy *wiphy, const struct station_parameters *params);
 void dump_station_parameters(void *sel, struct wiphy *wiphy, const struct station_parameters *params)
 {
 #if DBG_RTW_CFG80211_STA_PARAM
@@ -10093,6 +10103,8 @@ int rtw_hostapd_acs_dump_survey(struct wiphy *wiphy, struct net_device *netdev,
 #endif /* defined(CONFIG_RTW_HOSTAPD_ACS) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)) */
 
 #if (KERNEL_VERSION(4, 17, 0) <= LINUX_VERSION_CODE)
+int cfg80211_rtw_external_auth(struct wiphy *wiphy, struct net_device *dev,
+	struct cfg80211_external_auth_params *params);
 int cfg80211_rtw_external_auth(struct wiphy *wiphy, struct net_device *dev,
 	struct cfg80211_external_auth_params *params)
 {
diff --git a/drivers/staging/rtl8812au/os_dep/linux/ioctl_linux.c b/drivers/staging/rtl8812au/os_dep/linux/ioctl_linux.c
index c5776117f..27eb11239 100644
--- a/drivers/staging/rtl8812au/os_dep/linux/ioctl_linux.c
+++ b/drivers/staging/rtl8812au/os_dep/linux/ioctl_linux.c
@@ -188,6 +188,7 @@ void indicate_wx_scan_complete_event(_adapter *padapter)
 #endif
 }
 
+void rtw_indicate_wx_assoc_event(_adapter *padapter);
 void rtw_indicate_wx_assoc_event(_adapter *padapter)
 {
 	union iwreq_data wrqu;
@@ -211,6 +212,7 @@ void rtw_indicate_wx_assoc_event(_adapter *padapter)
 #endif
 }
 
+void rtw_indicate_wx_disassoc_event(_adapter *padapter);
 void rtw_indicate_wx_disassoc_event(_adapter *padapter)
 {
 	union iwreq_data wrqu;
diff --git a/drivers/staging/rtl8812au/os_dep/linux/os_intfs.c b/drivers/staging/rtl8812au/os_dep/linux/os_intfs.c
index f4f2ef90e..0b95a14e5 100644
--- a/drivers/staging/rtl8812au/os_dep/linux/os_intfs.c
+++ b/drivers/staging/rtl8812au/os_dep/linux/os_intfs.c
@@ -836,6 +836,7 @@ uint rtw_suspend_type = RTW_SUSPEND_TYPE;
 module_param(rtw_suspend_type, uint, 0644);
 #endif
 
+void rtw_regsty_load_target_tx_power(struct registry_priv *regsty);
 void rtw_regsty_load_target_tx_power(struct registry_priv *regsty)
 {
 	int path, rs;
@@ -1351,7 +1352,8 @@ static struct net_device_stats *rtw_net_get_stats(struct net_device *pnetdev)
 static const u16 rtw_1d_to_queue[8] = { 2, 3, 3, 2, 1, 1, 0, 0 };
 
 /* Given a data frame determine the 802.1p/1d tag to use. */
-unsigned int rtw_classify8021d(struct sk_buff *skb)
+unsigned int rtw_classify8021d(struct sk_buff *skb);
+unsigned int rtw_classify8021d(struct sk_buff *skb)
 {
 	unsigned int dscp;
 
@@ -1499,6 +1501,7 @@ void rtw_ndev_notifier_unregister(void)
 	unregister_netdevice_notifier(&rtw_ndev_notifier);
 }
 
+int rtw_ndev_init(struct net_device *dev);
 int rtw_ndev_init(struct net_device *dev)
 {
 	_adapter *adapter = rtw_netdev_priv(dev);
@@ -1512,6 +1515,7 @@ int rtw_ndev_init(struct net_device *dev)
 	return 0;
 }
 
+void rtw_ndev_uninit(struct net_device *dev);
 void rtw_ndev_uninit(struct net_device *dev)
 {
 	_adapter *adapter = rtw_netdev_priv(dev);
@@ -1584,6 +1588,7 @@ int rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname)
 	return 0;
 }
 
+void rtw_hook_if_ops(struct net_device *ndev);
 void rtw_hook_if_ops(struct net_device *ndev)
 {
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29))
@@ -1676,6 +1681,7 @@ struct net_device *rtw_init_netdev(_adapter *old_padapter)
 	return pnetdev;
 }
 
+int rtw_os_ndev_alloc(_adapter *adapter);
 int rtw_os_ndev_alloc(_adapter *adapter)
 {
 	int ret = _FAIL;
@@ -1730,6 +1736,7 @@ void rtw_os_ndev_free(_adapter *adapter)
 	}
 }
 
+int rtw_os_ndev_register(_adapter *adapter, const char *name);
 int rtw_os_ndev_register(_adapter *adapter, const char *name)
 {
 	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
@@ -1872,6 +1879,7 @@ void rtw_os_ndev_deinit(_adapter *adapter)
 	rtw_os_ndev_free(adapter);
 }
 
+int rtw_os_ndevs_alloc(struct dvobj_priv *dvobj);
 int rtw_os_ndevs_alloc(struct dvobj_priv *dvobj)
 {
 	int i, status = _SUCCESS;
@@ -1925,6 +1933,7 @@ int rtw_os_ndevs_alloc(struct dvobj_priv *dvobj)
 	return status;
 }
 
+void rtw_os_ndevs_free(struct dvobj_priv *dvobj);
 void rtw_os_ndevs_free(struct dvobj_priv *dvobj)
 {
 	int i;
@@ -2056,6 +2065,7 @@ void rtw_stop_drv_threads(_adapter *padapter)
 	rtw_hal_stop_thread(padapter);
 }
 
+u8 rtw_init_default_value(_adapter *padapter);
 u8 rtw_init_default_value(_adapter *padapter)
 {
 	u8 ret  = _SUCCESS;
@@ -3141,6 +3151,7 @@ void rtw_inetaddr_notifier_unregister(void)
 #endif
 }
 
+int rtw_os_ndevs_register(struct dvobj_priv *dvobj);
 int rtw_os_ndevs_register(struct dvobj_priv *dvobj)
 {
 	int i, status = _SUCCESS;
@@ -3260,6 +3271,7 @@ void rtw_os_ndevs_deinit(struct dvobj_priv *dvobj)
 }
 
 #ifdef CONFIG_BR_EXT
+void netdev_br_init(struct net_device *netdev);
 void netdev_br_init(struct net_device *netdev)
 {
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(netdev);
@@ -3899,6 +3911,7 @@ static int netdev_close(struct net_device *pnetdev)
 
 }
 
+int pm_netdev_close(struct net_device *pnetdev, u8 bnormal);
 int pm_netdev_close(struct net_device *pnetdev, u8 bnormal)
 {
 	int status = 0;
@@ -4585,6 +4598,7 @@ int rtw_suspend_ap_wow(_adapter *padapter)
 }
 #endif /* #ifdef CONFIG_AP_WOWLAN */
 
+int rtw_suspend_normal(_adapter *padapter);
 int rtw_suspend_normal(_adapter *padapter)
 {
 	int ret = _SUCCESS;
@@ -4991,6 +5005,7 @@ int rtw_resume_process_ap_wow(_adapter *padapter)
 }
 #endif /* #ifdef CONFIG_APWOWLAN */
 
+void rtw_mi_resume_process_normal(_adapter *padapter);
 void rtw_mi_resume_process_normal(_adapter *padapter)
 {
 	int i;
@@ -5020,6 +5035,7 @@ void rtw_mi_resume_process_normal(_adapter *padapter)
 	}
 }
 
+int rtw_resume_process_normal(_adapter *padapter);
 int rtw_resume_process_normal(_adapter *padapter)
 {
 	struct net_device *pnetdev;
diff --git a/drivers/staging/rtl8812au/os_dep/linux/rtw_android.c b/drivers/staging/rtl8812au/os_dep/linux/rtw_android.c
index 480ea83f9..bd599ecd3 100644
--- a/drivers/staging/rtl8812au/os_dep/linux/rtw_android.c
+++ b/drivers/staging/rtl8812au/os_dep/linux/rtw_android.c
@@ -364,6 +364,7 @@ int rtw_android_cmdstr_to_num(char *cmdstr)
 	return cmd_num;
 }
 
+int rtw_android_get_rssi(struct net_device *net, char *command, int total_len);
 int rtw_android_get_rssi(struct net_device *net, char *command, int total_len)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
@@ -379,6 +380,7 @@ int rtw_android_get_rssi(struct net_device *net, char *command, int total_len)
 	return bytes_written;
 }
 
+int rtw_android_get_link_speed(struct net_device *net, char *command, int total_len);
 int rtw_android_get_link_speed(struct net_device *net, char *command, int total_len)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
@@ -391,6 +393,7 @@ int rtw_android_get_link_speed(struct net_device *net, char *command, int total_
 	return bytes_written;
 }
 
+int rtw_android_get_macaddr(struct net_device *net, char *command, int total_len);
 int rtw_android_get_macaddr(struct net_device *net, char *command, int total_len)
 {
 	int bytes_written = 0;
@@ -399,6 +402,7 @@ int rtw_android_get_macaddr(struct net_device *net, char *command, int total_len
 	return bytes_written;
 }
 
+int rtw_android_set_country(struct net_device *net, char *command, int total_len);
 int rtw_android_set_country(struct net_device *net, char *command, int total_len)
 {
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
@@ -410,6 +414,7 @@ int rtw_android_set_country(struct net_device *net, char *command, int total_len
 	return (ret == _SUCCESS) ? 0 : -1;
 }
 
+int rtw_android_get_p2p_dev_addr(struct net_device *net, char *command, int total_len);
 int rtw_android_get_p2p_dev_addr(struct net_device *net, char *command, int total_len)
 {
 	int bytes_written = 0;
@@ -421,6 +426,7 @@ int rtw_android_get_p2p_dev_addr(struct net_device *net, char *command, int tota
 	return bytes_written;
 }
 
+int rtw_android_set_block_scan(struct net_device *net, char *command, int total_len);
 int rtw_android_set_block_scan(struct net_device *net, char *command, int total_len)
 {
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
@@ -433,6 +439,7 @@ int rtw_android_set_block_scan(struct net_device *net, char *command, int total_
 	return 0;
 }
 
+int rtw_android_set_block(struct net_device *net, char *command, int total_len);
 int rtw_android_set_block(struct net_device *net, char *command, int total_len)
 {
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
@@ -445,6 +452,7 @@ int rtw_android_set_block(struct net_device *net, char *command, int total_len)
 	return 0;
 }
 
+int rtw_android_setband(struct net_device *net, char *command, int total_len);
 int rtw_android_setband(struct net_device *net, char *command, int total_len)
 {
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
@@ -458,6 +466,7 @@ int rtw_android_setband(struct net_device *net, char *command, int total_len)
 	return (ret == _SUCCESS) ? 0 : -1;
 }
 
+int rtw_android_getband(struct net_device *net, char *command, int total_len);
 int rtw_android_getband(struct net_device *net, char *command, int total_len)
 {
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
@@ -469,6 +478,7 @@ int rtw_android_getband(struct net_device *net, char *command, int total_len)
 }
 
 #ifdef CONFIG_WFD
+int rtw_android_set_miracast_mode(struct net_device *net, char *command, int total_len);
 int rtw_android_set_miracast_mode(struct net_device *net, char *command, int total_len)
 {
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
@@ -505,6 +515,7 @@ int rtw_android_set_miracast_mode(struct net_device *net, char *command, int tot
 }
 #endif /* CONFIG_WFD */
 
+int get_int_from_command(char *pcmd);
 int get_int_from_command(char *pcmd)
 {
 	int i = 0;
diff --git a/drivers/staging/rtl8812au/os_dep/linux/rtw_proc.c b/drivers/staging/rtl8812au/os_dep/linux/rtw_proc.c
index 840a675cc..db1177c3a 100644
--- a/drivers/staging/rtl8812au/os_dep/linux/rtw_proc.c
+++ b/drivers/staging/rtl8812au/os_dep/linux/rtw_proc.c
@@ -483,6 +483,7 @@ static int proc_get_rf_reg_dump(struct seq_file *m, void *v)
 }
 
 #ifdef CONFIG_RTW_LED
+int proc_get_led_config(struct seq_file *m, void *v);
 int proc_get_led_config(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
@@ -493,6 +494,7 @@ int proc_get_led_config(struct seq_file *m, void *v)
 	return 0;
 }
 
+ssize_t proc_set_led_config(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 ssize_t proc_set_led_config(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
@@ -525,6 +527,7 @@ ssize_t proc_set_led_config(struct file *file, const char __user *buffer, size_t
 #endif /* CONFIG_RTW_LED */
 
 #ifdef CONFIG_AP_MODE
+int proc_get_aid_status(struct seq_file *m, void *v);
 int proc_get_aid_status(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
@@ -535,6 +538,7 @@ int proc_get_aid_status(struct seq_file *m, void *v)
 	return 0;
 }
 
+ssize_t proc_set_aid_status(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 ssize_t proc_set_aid_status(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
@@ -1287,6 +1291,7 @@ static int proc_get_macaddr_acl(struct seq_file *m, void *v)
 	return 0;
 }
 
+ssize_t proc_set_macaddr_acl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 ssize_t proc_set_macaddr_acl(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
@@ -1745,6 +1750,7 @@ static ssize_t proc_set_dfs_slave_with_rd(struct file *file, const char __user *
 #endif /* CONFIG_DFS_MASTER */
 
 #ifdef CONFIG_80211N_HT
+int proc_get_rx_ampdu_size_limit(struct seq_file *m, void *v);
 int proc_get_rx_ampdu_size_limit(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
@@ -1755,6 +1761,7 @@ int proc_get_rx_ampdu_size_limit(struct seq_file *m, void *v)
 	return 0;
 }
 
+ssize_t proc_set_rx_ampdu_size_limit(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 ssize_t proc_set_rx_ampdu_size_limit(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
@@ -2765,6 +2772,7 @@ int proc_get_mbid_cam_cache(struct seq_file *m, void *v)
 }
 #endif /* CONFIG_MBSSID_CAM */
 
+int proc_get_mac_addr(struct seq_file *m, void *v);
 int proc_get_mac_addr(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
@@ -3146,6 +3154,7 @@ static ssize_t proc_set_napi_th(struct file *file, const char __user *buffer, si
 #endif /* CONFIG_RTW_NAPI_DYNAMIC */
 
 
+ssize_t proc_set_dynamic_agg_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 ssize_t proc_set_dynamic_agg_enable(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *dev = data;
@@ -3775,6 +3784,7 @@ static ssize_t proc_set_tpt_mode(struct file *file, const char __user *buffer,
 }
 #endif /* CONFIG_RTW_TPT_MODE */
 
+int proc_get_cur_beacon_keys(struct seq_file *m, void *v);
 int proc_get_cur_beacon_keys(struct seq_file *m, void *v)
 {
 	struct net_device *dev = m->private;
@@ -4281,6 +4291,7 @@ ssize_t proc_set_odm_adaptivity(struct file *file, const char __user *buffer, si
 static char *phydm_msg = NULL;
 #define PHYDM_MSG_LEN	80*24
 
+int proc_get_phydm_cmd(struct seq_file *m, void *v);
 int proc_get_phydm_cmd(struct seq_file *m, void *v)
 {
 	struct net_device *netdev;
@@ -4308,6 +4319,7 @@ int proc_get_phydm_cmd(struct seq_file *m, void *v)
 	return 0;
 }
 
+ssize_t proc_set_phydm_cmd(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data);
 ssize_t proc_set_phydm_cmd(struct file *file, const char __user *buffer, size_t count, loff_t *pos, void *data)
 {
 	struct net_device *netdev;
@@ -4477,6 +4489,7 @@ struct proc_dir_entry *rtw_odm_proc_init(struct net_device *dev)
 	return dir_odm;
 }
 
+void rtw_odm_proc_deinit(_adapter	*adapter);
 void rtw_odm_proc_deinit(_adapter	*adapter)
 {
 	struct proc_dir_entry *dir_odm = NULL;
diff --git a/drivers/staging/rtl8812au/os_dep/linux/usb_intf.c b/drivers/staging/rtl8812au/os_dep/linux/usb_intf.c
index a285c011c..915ef6476 100644
--- a/drivers/staging/rtl8812au/os_dep/linux/usb_intf.c
+++ b/drivers/staging/rtl8812au/os_dep/linux/usb_intf.c
@@ -951,6 +951,7 @@ static int rtw_suspend(struct usb_interface *pusb_intf, pm_message_t message)
 	return ret;
 }
 
+int rtw_resume_process(_adapter *padapter);
 int rtw_resume_process(_adapter *padapter)
 {
 	int ret;
diff --git a/drivers/staging/rtl8812au/os_dep/linux/usb_ops_linux.c b/drivers/staging/rtl8812au/os_dep/linux/usb_ops_linux.c
index fd03f8696..c7eb7ea40 100644
--- a/drivers/staging/rtl8812au/os_dep/linux/usb_ops_linux.c
+++ b/drivers/staging/rtl8812au/os_dep/linux/usb_ops_linux.c
@@ -705,6 +705,7 @@ void usb_write_port_cancel(struct intf_hdl *pintfhdl)
 	}
 }
 
+void usb_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf);
 void usb_init_recvbuf(_adapter *padapter, struct recv_buf *precvbuf)
 {
 
diff --git a/drivers/staging/rtl8812au/os_dep/linux/xmit_linux.c b/drivers/staging/rtl8812au/os_dep/linux/xmit_linux.c
index f08dd8e8c..c931a8014 100644
--- a/drivers/staging/rtl8812au/os_dep/linux/xmit_linux.c
+++ b/drivers/staging/rtl8812au/os_dep/linux/xmit_linux.c
@@ -366,6 +366,7 @@ void rtw_os_wake_queue_at_free_stainfo(_adapter *padapter, int *qcnt_freed)
 }
 
 #ifdef CONFIG_TX_MCAST2UNI
+int rtw_mlcst2unicst(_adapter *padapter, struct sk_buff *skb);
 int rtw_mlcst2unicst(_adapter *padapter, struct sk_buff *skb)
 {
 	struct	sta_priv *pstapriv = &padapter->stapriv;
diff --git a/drivers/staging/rtl8812au/os_dep/osdep_service.c b/drivers/staging/rtl8812au/os_dep/osdep_service.c
index d24b3e1f0..5b2aa5d00 100644
--- a/drivers/staging/rtl8812au/os_dep/osdep_service.c
+++ b/drivers/staging/rtl8812au/os_dep/osdep_service.c
@@ -2258,6 +2258,7 @@ void rtw_free_netdev(struct net_device *netdev)
 	return;
 }
 
+int rtw_change_ifname(_adapter *padapter, const char *ifname);
 int rtw_change_ifname(_adapter *padapter, const char *ifname)
 {
 	struct dvobj_priv *dvobj;
diff --git a/drivers/staging/rtl8812au/platform/platform_ops.c b/drivers/staging/rtl8812au/platform/platform_ops.c
index 10766aad8..eac273047 100644
--- a/drivers/staging/rtl8812au/platform/platform_ops.c
+++ b/drivers/staging/rtl8812au/platform/platform_ops.c
@@ -18,6 +18,7 @@
  *	0:	power on successfully
  *	others: power on failed
  */
+int platform_wifi_power_on(void);
 int platform_wifi_power_on(void)
 {
 	int ret = 0;
@@ -26,6 +27,7 @@ int platform_wifi_power_on(void)
 	return ret;
 }
 
+void platform_wifi_power_off(void);
 void platform_wifi_power_off(void)
 {
 }
-- 
2.41.1

